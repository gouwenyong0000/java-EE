
1. Set及其实现类特点
java.util.Collection:存储一个一个的数据
    |-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
           |---- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）
                |---- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了
                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺序
                                     实现遍历。便于频繁的查询操作。
           |---- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。


2. 开发中的使用频率及场景：
> 较List、Map来说，Set使用的频率比较少。
> 用来过滤重复数据

3. Set中常用方法：即为Collection中声明的15个抽象方法。没有新增的方法。

4. Set中无序性、不可重复性的理解（以HashSet及其子类为例说明）

>无序性： != 随机性。
         添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!
         到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。
         这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。

>不可重复性：添加到Set中的元素是不能相同的。
          比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。
          哈希值相同且equals()返回true，则认为元素是相同的。


5. 添加到HashSet/LinkedHashSet中元素的要求:
  要求元素所在的类要重写两个方法：equals() 和 hashCode()。
  同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。


6. TreeSet的使用
6.1 底层的数据结构：红黑树

6.2 添加数据后的特点：可以按照添加的元素的指定的属性的大小顺序进行遍历。


6.3 向TreeSet中添加的元素的要求：
> 要求添加到TreeSet中的元素必须是同一个类型的对象，否则会报ClassCastException.
> 添加的元素需要考虑排序：① 自然排序 ② 定制排序

6.4 判断数据是否相同的标准
> 不再是考虑hashCode()和equals()方法了，也就意味着添加到TreeSet中的元素所在的类不需要重写hashCode()和equals()方法了
> 比较元素大小的或比较元素是否相等的标准就是考虑自然排序或定制排序中，compareTo()或compare()的返回值。
  如果compareTo()或compare()的返回值为0，则认为两个对象是相等的。由于TreeSet中不能存放相同的元素，则
  后一个相等的元素就不能添加到TreeSet中。

