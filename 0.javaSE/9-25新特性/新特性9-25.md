

## Java 学习笔记：核心新特性 (Java 9-11 及更高)



### 1. Java 版本变更历史与发布模式 (JEP 223)

<img src="C:\Users\gouwe\Desktop\images\新特性\image-20251119011536883.png" alt="image-20251119011536883" />

这项“特性”是理解后续所有内容的基础。

- **适用版本：** Java 9 开始
- **解决了什么问题：**
  - 在 Java 9 之前，Java 的发布周期非常漫长且不可预测（例如 Java 6 到 7 隔了 5 年，7 到 8 隔了 3 年）。
  - 这导致新功能（如 Lambda）需要等待数年才能交付给开发者。
  - 大型的、捆绑式的“功能驱动”发布模式（Feature-driven）风险高，容易导致延期。
- **之前的解决方案：** "功能驱动"发布。即“等所有大功能都做完了再发布”。
- **新的解决方案 (Java 9+)：**
  1. **"时间驱动"发布 (Time-driven)：** 严格遵守**每 6 个月**发布一个新版本的节奏（每年 3 月和 9 月）。
  2. **LTS (Long-Term Support) 版本：** 引入 "长期支持版" 概念。
     - **Java 8** 是旧模式的最后一个 LTS。
     - **Java 11** 是新模式下的第一个 LTS。
     - **Java 17** 是第二个 LTS。
     - **Java 21** 是当前的 LTS。
     - LTS 版本会获得数年的安全和错误修复支持（由 Oracle 和其他厂商如 Red Hat, Amazon 提供）。
  3. **非 LTS 版本：** 只会获得 6 个月的支持（直到下一个版本发布）。
- **面试常见问题：**
  - **Q:** 什么是 Java 的 LTS 版本？
  - **A:** LTS (Long-Term Support) 指长期支持版本。与每 6 个月发布一次的“功能版本”不同，LTS 版本会获得长达数年的官方安全更新和错误修复，因此更适合用于生产环境。目前主流的 LTS 版本有 Java 8, 11, 17, 21。
  - **Q:** 你们公司目前在用哪个 Java 版本？为什么选择它？
  - **A:** (你需要根据自己情况回答) 常见的回答是：“我们目前主要使用 Java 8，因为它稳定且生态成熟，但我们正在计划/调研升级到 Java 11 或 17，以利用... (例如：ZGC、模块化、HttpClient、var 语法等)。”

------

## JDK9-11

### 2. 模块化系统 (Project Jigsaw) (JEP 261)

- **适用版本：** Java 9

- **解决了什么问题：**

  1. **Classpath Hell (类路径地狱)：** 难以管理的 JAR 包依赖，容易发生类冲突。
  2. **JDK 过于臃肿：** 以前的 `rt.jar` 非常巨大 (约 60MB+)，包含了所有 Java 核心类，无论你是否需要它们。
  3. **弱封装性：** Java 只有 `public`, `protected`, `(default)`, `private` 四种访问级别。对于一个库 (JAR) 来说，任何 `public` 类都对外部可见，无法隐藏内部的实现细节（例如 `sun.misc.Unsafe` 长期被滥用）。

- **之前的解决方案：** 依赖 Classpath。所有 `public` 类都暴露在外，靠文档约定和 `internal`, `impl` 这样的包名来“劝告”用户不要使用。

- **新的解决方案：** 引入 `module` (模块) 概念。

  - 在项目的根目录（例如 `src/`）下创建一个 `module-info.java` 文件。
  - **`requires`** 关键字：声明本模块依赖哪些其他模块。
  - **`exports`** 关键字：声明本模块对外暴露哪些包 (package)。
  - **强封装：** 默认情况下，即使是 `public` 类，如果它所在的包没有被 `exports`，其他模块也无法访问它。

- **代码对比：**

  - **之前 (Java 8)：** 没有模块概念，所有 `public` 类都可被访问。

  - **之后 (Java 9)：**

    ```java
    // 文件名: module-info.java
    // 假设这是一个名为 com.my.library 的模块
    module com.my.library {
    
        // 1. 声明依赖：本模块需要 java.sql 模块中的 API
        requires java.sql;
    
        // 2. 声明导出：只将 .api 包暴露给其他模块使用
        exports com.my.library.api;
    
        // 3. 验证点：
        // 假设你还有一个 com.my.library.internal 包，
        // 里面有 public class InternalCache { ... }
        // 因为 .internal 包没有被 'exports'，
        // 所以其他模块即使 'requires com.my.library'，
        // 也无法访问 InternalCache 类，实现了真正的封装。
    }
    ```

- **面试常见问题：**

  - **Q:** 什么是 Java 模块化 (JPMS)？它解决了什么问题？
  - **A:** 解决了类路径地狱、JDK 臃肿和弱封装问题。通过 `module-info.java` 中的 `requires` 和 `exports` 关键字，模块可以明确声明依赖，并真正隐藏内部实现（未 `exports` 的 `public` 类外界不可见）。
  - **Q:** `requires` 和 `exports` 是做什么用的？
  - **A:** `requires` 用来声明依赖，`exports` 用来暴露 API。

------



### 3. 接口的私有方法

- **适用版本：** Java 9

- **解决了什么问题：**

  - Java 8 允许在接口中使用 `default` (默认) 方法。
  - **问题是：** 如果多个 `default` 方法需要共享一段重复的逻辑，这段逻辑代码要么被复制粘贴，要么就必须被定义为一个 `public static` 方法。
  - 将辅助方法（helper method）暴露为 `public` 污染了接口的 API。

- **之前的解决方案 (Java 8)：**

  - 1. 在多个 `default` 方法中复制代码。
  - 1. 定义一个 `public static` 辅助方法（但它对所有实现类都可见）。

- **新的解决方案 (Java 9)：** 允许在接口中定义 `private` 和 `private static` 方法。

- **代码对比：**

  - **之前 (Java 8)：**

    ```Java
    interface OldService {
        // 默认方法1
        default void functionA() {
            // ...一些逻辑
            System.out.println("执行通用日志记录"); // 重复代码
            // ...其他逻辑
        }
    
        // 默认方法2
        default void functionB() {
            // ...一些逻辑
            System.out.println("执行通用日志记录"); // 重复代码
            // ...其他逻辑
        }
    
        // 或者，使用一个 public static 辅助方法，但这污染了 API
        static void logHelper() {
            System.out.println("执行通用日志记录");
        }
    }
    ```

  - **之后 (Java 9)：**

    ```Java
    interface NewService {
        // 默认方法1
        default void functionA() {
            // ...一些逻辑
            log(); // 调用私有方法
            // ...其他逻辑
        }
    
        // 默认方法2
        default void functionB() {
            // ...一些逻辑
            log(); // 调用私有方法
            // ...其他逻辑
        }
    
        // 验证点：
        // 定义一个私有方法，仅在接口内部可见
        // 它不能是 abstract 的，必须有方法体
        private void log() {
            System.out.println("执行通用日志记录");
        }
    }
    ```

- **面试常见问题：**

  - **Q:** 为什么 Java 9 要在接口中引入私有方法？
  - **A:** 主要为了辅助 Java 8 的 `default` 方法。当多个 `default` 方法需要共享代码时，可以使用 `private` 方法来封装这部分共享逻辑，避免代码重复，同时又不会将这个辅助方法暴露给接口的实现类。

------

| 特性       | 抽象类（Abstract Class）                                     | 接口（Interface）                                            |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义关键字 | `abstract class`                                             | `interface`                                                  |
| 方法类型   | 可以包含抽象方法和具体实现的方法                             | Java 8前只能是抽象方法；之后可包含 `default` 方法、`static` 方法、私有方法 |
| 成员变量   | 可以是普通变量、常量（`final`）                              | 默认都是 `public static final` 的常量                        |
| 构造方法   | 有构造方法，用于子类初始化                                   | 没有构造方法                                                 |
| 继承关系   | 单继承：一个类只能继承一个抽象类                             | 多实现：一个类可以实现多个接口                               |
| 访问修饰符 | 方法可以用任意修饰符（`public`, `protected`, `private`）     | 方法默认是 `public`（Java 9起，私有方法可以是 `private`）    |
| 代码复用   | 强，通过具体方法和继承来复用代码                             | 弱，Java 8后通过 `default` 方法提供有限的复用                |
| 层次结构   | 通常用于在紧密相关的类之间建立自上而下的层次结构             | 通常用于为不相关的类定义共同的行为                           |
| 设计理念   | "is-a" 关系，表示一种分类关系。（例如：Manager is an Employee） | "has-a" / "can-do" 关系，表示一种能力或契约。（例如：Bird can Fly, Plane can Fly） |
| 关注点     | 关注“是什么”，你控制的类族，有清晰的“is-a”关系：比如 Animal → Dog / Cat，Vehicle → Car / Truck。这些子类本质上是同一种事物，只是具体形态和行为略有不同。 | 关注“能做什么”，定义一种契约，而不关心谁来实现它：比如，一个排序方法只关心传入的对象是否实现了 Comparable 接口，而不关心它具体是字符串、数字还是自定义对象。 |

### 4. 字符串底层结构变化与新增方法

#### (1) 底层结构变化 (Compact Strings) (JEP 254)

- **适用版本：** Java 9
- **解决了什么问题：** 内存占用过高。
- **之前的解决方案 (Java 8)：** `String` 内部是基于一个 `char[]` 数组存储的。在 Java 中，一个 `char` 占用 2 个字节 (UTF-16)。
  - **问题：** 绝大多数（尤其是英文）的字符串都只包含 Latin-1 字符，这些字符本可以用 1 个字节存储。但 Java 8 统一使用 2 个字节，导致了 50% 的内存空间浪费。
- **新的解决方案 (Java 9)：**
  - `String` 内部存储从 `char[]` (2字节/字符) 改为了 `byte[]` (1字节/字符)。
  - 增加了一个 `coder` 字段，用于标记编码：
    - `LATIN1` (0)：表示该字符串只包含 Latin-1 字符，每个字符用 1 个字节存储在 `byte[]` 中。
    - `UTF16` (1)：表示该字符串包含 Latin-1 之外的字符（如中文）。此时，它会像 Java 8 一样，每 2 个字节（`byte[]` 中相邻的两个元素）组合成一个 `char`。
  - 这个优化对开发者透明，但在处理大量纯英文/数字字符串时，可以节省近一半的堆内存。
- **源码解读 (对比)：**
  - **Java 8 (String.java)：** `private final char[] value;`
  - **Java 9+ (String.java)：** `private final byte[] value;` 和 `private final byte coder;`
- **面试常见问题：**
  - **Q:** Java 9 对 String 做了什么重要优化？
  - **A:** 引入了 "Compact Strings" (紧凑字符串)。底层存储从 `char[]` (2字节/字符) 改为 `byte[]`。==如果字符串只包含 Latin-1 字符，就用 1 字节存储==；如果包含其他字符（如中文），才用 2 字节存储。这个优化旨在节省内存。



#### (2) 新增方法 (Java 11)

| 方法签名                   | 功能描述                                                     | 示例                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `boolean isBlank()`        | 判断字符串是否为 “空白”（仅包含空白字符，或长度为 0）        | `"\t\n"`.isBlank() → true，`"a"`.isBlank() → false           |
| `String strip()`           | 去除字符串首尾的 “空白字符”（比`trim()`更彻底，支持 Unicode 空白字符） | `" 你好 "`.strip () → "你好"，`"\u2000a\u2000"`.strip() → "a" |
| `String stripLeading()`    | 仅去除字符串开头的空白字符                                   | `" abc "`.stripLeading() → "abc "                            |
| `String stripTrailing()`   | 仅去除字符串结尾的空白字符                                   | `" abc "`.stripTrailing() → " abc"                           |
| `Stream<String> lines()`   | 将字符串按 “换行符” 分割为`Stream`流（支持`\n`、`\r\n`、`\r`等换行格式） | `"a\nb\r\nc"`.lines().collect(Collectors.toList()) → ["a", "b", "c"] |
| `String repeat(int count)` | 将字符串重复`count`次并拼接（`count`为 0 时返回空字符串）    | `"ab"`.repeat(3) → "ababab"，`"a"`.repeat(0) → ""            |



- **适用版本：** Java 11 (部分来自 Java 9/10)

- **`isBlank()` (Java 11):**

  - **解决问题：** `isEmpty()` 无法判断 " " (只有空格) 的字符串。

  - **对比：**

    ```Java
    String s = "   ";
    // 之前 (Java 8)
    System.out.println(s.isEmpty()); // false
    System.out.println(s.trim().isEmpty()); // true (需要 trim 才能判断)
    
    // 之后 (Java 11)
    // 验证点：isBlank() 会判断是否为空，或者只包含空白符
    System.out.println(s.isBlank()); // true 
    ```
  
- **`strip()`, `stripLeading()`, `stripTrailing()` (Java 11):**

  - **解决问题：** `trim()` 只能去除半角空格 (ASCII <= 32)，无法去除全角空格或其他 Unicode 空白符。

  - **对比：**

    ```Java
    String s = "  Hello \u2005"; // \u2005 是一个 Unicode 空白符
    // 之前 (Java 8)
    System.out.println("'" + s.trim() + "'"); // 'Hello  ' (无法去除 \u2005)
    
    // 之后 (Java 11)
    // 验证点：strip() 可以识别所有 Unicode 空白符
    System.out.println("'" + s.strip() + "'"); // 'Hello' (全部去除)
    ```
  
- **`lines()` (Java 11):**

  - **解决问题：** 方便地按行分割字符串。

  - **对比：**

    ```Java
    String multiLine = "Line 1\nLine 2\r\nLine 3";
    // 之前 (Java 8)
    String[] lines = multiLine.split("\\R");
    Stream<String> stream = Arrays.stream(lines);
    
    // 之后 (Java 11)
    // 验证点：返回一个 Stream<String>
    Stream<String> stream = multiLine.lines();
    stream.forEach(System.out::println);
    ```
  
- **`repeat(int)` (Java 11):**

  - **解决问题：** 重复字符串。

  - **对比：**

    ```Java
    // 之前 (Java 8)：需要循环或使用第三方库
    
    // 之后 (Java 11)
    String s = "Hi_";
    System.out.println(s.repeat(3)); // "Hi_Hi_Hi_"
    ```

------



### 5. 集合工厂方法 (JEP 269)

- **适用版本：** Java 9

- **解决了什么问题：** 创建一个包含少量元素的**不可变** (Immutable) 集合非常繁琐。

- **之前的解决方案 (Java 8)：**

  ```Java
  // 方案1：繁琐 且会被修改
  List<String> list1 = new ArrayList<>();
  list1.add("A");
  list1.add("B");
  List<String> list2 = Collections.unmodifiableList(list1);
  list1.add("C");
  System.out.println(list2); // [A, B, C] 不可变集合会被修改
  
  // 方案2："双大括号初始化" (匿名内部类)，但有性能和内存泄漏风险
  List<String> list2 = new ArrayList<>() {{
      add("A");
      add("B");
  }};
  ```

- **新的解决方案 (Java 9)：** `List.of()`, `Set.of()`, `Map.of()`。

  - 在 Java 10 中，集合框架新增了`List.copyOf()`、`Set.copyOf()`、`Map.copyOf()`方法，用于从**已有的集合（或可迭代对象）** 创建不可变副本。它们与 Java 9 的`of()`方法相辅相成

  - `copyOf()`是对`of()`方法的补充：`of()`适合 “从无到有” 创建不可变集合，`copyOf()`适合 “基于已有集合” 创建不可变副本。两者共同简化了不可变集合的创建逻辑，同时保证了数据稳定性和线程安全

- **代码对比：**

  ```Java
  // 之后 (Java 9)
  // 1. 创建不可变 List
  List<String> list = List.of("A", "B", "C");
  
  // 2. 创建不可变 Set
  Set<String> set = Set.of("X", "Y");
  
  // 3. 创建不可变 Map (最多 10 对 key-value)
  Map<Integer, String> map = Map.of(1, "One", 2, "Two");
  
  // 验证点 1：不可变性
  try {
      list.add("D"); // 会抛出 UnsupportedOperationException
  } catch (Exception e) {
      e.printStackTrace();
  }
  
  // 验证点 2：不允许 null 元素
  try {
      List.of("A", null); // 会抛出 NullPointerException
  } catch (Exception e) {
      e.printStackTrace();
  }
  ```

  ```java
  public class CopyOfDemo {
      public static void main(String[] args) {
          // 1. 源集合（可变）
          List<String> source = new ArrayList<>();
          source.add("A");
          source.add("B");
  
          // 2. 使用copyOf()创建不可变副本
          List<String> copy = List.copyOf(source);
          System.out.println(copy); // [A, B]
  
          // 3. 源集合修改，副本不受影响
          source.add("C");
          System.out.println(source); // [A, B, C]
          System.out.println(copy);   // [A, B]（副本不变）
  
          // 4. 副本不可修改
          try {
              copy.add("D");
          } catch (UnsupportedOperationException e) {
              e.printStackTrace(); // 抛出异常
          }
  
          // 5. 源集合包含null时，copyOf()抛NPE
          List<String> nullSource = new ArrayList<>();
          nullSource.add(null);
          try {
              List.copyOf(nullSource);
          } catch (NullPointerException e) {
              e.printStackTrace(); // 抛出异常
          }
      }
  }
  ```

  

- **面试常见问题：**

  - **Q:** `List.of()` 和 `new ArrayList()` 有什么区别？
  - **A:** `List.of()` 创建的是**不可变集合** (Immutable)，不能添加、删除或修改元素，也不能存 `null` 元素。`new ArrayList()` 创建的是可变集合。
  - **Q:** `List.of()` 有什么好处？
  - **A:** 1. 语法简洁。 2. 不可变性保证了线程安全和数据稳定。 3. 更节省内存（返回的是专门优化的内部类，如 `ListN`)。

------

> 总结：
>
> 1. **核心价值：简化不可变集合创建**
>
> Java 9 之前，创建不可变集合的方式存在明显缺陷：
>
> - `Collections.unmodifiableList()`只是 “包装” 可变集合，原集合修改会同步影响 “不可变” 集合（如示例中`list1.add("C")`导致`list2`变化）；
> - 双大括号初始化（`new ArrayList<>() {{ ... }}`）本质是创建匿名内部类，会隐式持有外部类引用，可能导致内存泄漏，且性能较差。
>
> 而`List.of()`等方法直接返回**真正的不可变集合**，从根源上避免了这些问题，且语法极简（一行代码即可创建）。
>
> 2. **关键特性**
>
> - **不可变性**：不支持`add()`、`remove()`、`set()`等修改操作，调用会抛出`UnsupportedOperationException`；
> - **禁止 null 元素**：创建时包含`null`会直接抛出`NullPointerException`（避免`null`引发的隐性 bug）；
> - **内存优化**：返回的是 JDK 内部优化的专用实现类（如`ListN`、`SetN`，N 为元素数量），而非通用的`ArrayList`/`HashSet`，结构更简单，内存占用更少；
> - **线程安全**：由于不可变，多线程环境下无需额外同步，天然线程安全。
>
> 3. **使用限制补充**
>
> - `Map.of()`最多支持**10 对键值对**，若需要更多，可使用`Map.ofEntries()`（通过`Map.entry(k, v)`创建 Entry 对象传入）：
>
>   ```java
>   Map<Integer, String> map = Map.ofEntries(
>       Map.entry(1, "One"),
>       Map.entry(2, "Two"),
>       // 可添加更多Entry
>   );
>   ```
>
> - 不可变集合的 “不可变” 指**结构不可变**（元素数量和引用不可改），但如果元素是可变对象（如自定义类），其内部状态仍可被修改（需注意这一点）

### 6. Stream API 增强 (Java 9)

- **适用版本：** Java 9

- **解决了什么问题：**

  1. `Stream.iterate()` 只能生成无限流，必须配合 `limit()` 使用。
  2. 缺少 "take elements *until*" (取元素直到...) 和 "drop elements *until*" (跳过元素直到...) 这种操作。
  3. `Stream` 中无法方便地处理 `null`。

- **新的解决方案：** `takeWhile()`, `dropWhile()`, `iterate()` (重载), `ofNullable()`。

- **代码对比：**

  **`takeWhile` 方法**从流的起始元素开始，逐个判断是否满足给定谓词（`Predicate`），**遇到第一个不满足条件的元素即停止**，保留此前所有满足条件的元素，功能类似 `for` 循环中的 `break`。

  > 适用场景：处理**有序流**时，需 “截取开头连续满足条件的一段元素” 的场景（如从有序数值流中提取开头连续的正数）。

  **`dropWhile` 方法**从流的起始元素开始，**丢弃所有满足谓词的元素，直到遇到第一个不满足条件的元素**，随后保留该元素及之后的所有元素，功能类似 `for` 循环中 “跳过前几个满足条件元素” 的逻辑。

  > 适用场景：处理**有序流**时，需 “跳过开头连续满足条件的一段元素，保留剩余部分” 的场景（如从有序字符串流中跳过开头连续的空字符串，处理后续有效内容）

  ```Java
  // 有序列表（注意：takeWhile/dropWhile 对无序流行为不确定，建议用于有序流）
  List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 3, 2);
  
  // 1. takeWhile：保留开头连续满足“小于4”的元素，遇到第一个不满足的（4）则停止
  List<Integer> takeResult = numbers.stream()
      .takeWhile(n -> n < 4)
      .collect(Collectors.toList());
  System.out.println("takeWhile(n < 4) 结果：" + takeResult); 
  // 输出：[1, 2, 3]（到4时不满足，停止提取）
  
  // 2. dropWhile：丢弃开头连续满足“小于4”的元素，遇到第一个不满足的（4）则保留后续所有元素
  List<Integer> dropResult = numbers.stream()
      .dropWhile(n -> n < 4)
      .collect(Collectors.toList());
  System.out.println("dropWhile(n < 4) 结果：" + dropResult); 
  // 输出：[4, 5, 3, 2]（丢弃1,2,3后，从4开始保留所有元素）
  ```

  **`iterate` (for 循环的 Stream 版本)**

  ```Java
  // 需求：生成 0, 1, 2, 3, 4
  
  // 之前 (Java 8)：必须用 limit() 限制
  Stream.iterate(0, n -> n + 1)
        .limit(5)
        .forEach(System.out::print); // 01234
  
  // 之后 (Java 9)：重载方法，自带停止条件
  // 验证点：iterate(初始值, 停止条件, 迭代操作)
  Stream.iterate(0, n -> n < 5, n -> n + 1)
        .forEach(System.out::print); // 01234
  ```

  **`ofNullable` (处理 null 的 Stream)**

  ```Java
  // 需求：一个方法可能返回 null，如果非 null 则处理，如果 null 则跳过
  String value = null; // 或者 value = "Hello"
  
  // 之前 (Java 8)：需要 if 判断
  if (value != null) {
      Stream.of(value).forEach(System.out::println);
  }
  
  // 之后 (Java 9)：
  // 验证点：如果 value 为 null，Stream.ofNullable(value) 会返回一个空 Stream
  Stream.ofNullable(value).forEach(System.out::println);
  ```

- **面试常见问题：**

  - **Q:** `takeWhile` 和 `filter` 有什么区别？
  - **A:** `filter` 会遍历 Stream 中的所有元素，对每个元素进行判断。`takeWhile` (用于有序流时) 从头开始遍历，一旦遇到第一个不满足条件的元素，就会*立即停止*后续的遍历（**短路操作**）。

------

### Java 9 中 `InputStream` 新增方法解析

1. `readAllBytes()` 方法

- **功能**：一次性读取输入流中**所有字节**，返回字节数组（`byte[]`）。
- **优势**：替代 Java 8 及之前 “手动循环读取 + 拼接字节数组” 的繁琐逻辑，代码简洁性大幅提升。

```java
// Java 8 及之前：读取输入流所有字节
public byte[] readAll(InputStream is) throws IOException {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024];
    int len;
    while ((len = is.read(buffer)) != -1) {
        baos.write(buffer, 0, len);
    }
    return baos.toByteArray();
}

// Java 9：读取输入流所有字节
byte [] bytes = is.readAllBytes ();
```

2. `transferTo(OutputStream out)` 方法

- **功能**：将当前输入流的所有数据**传输到目标输出流**，完成 “流到流” 的数据拷贝。
- **优势**：替代 Java 8 及之前 “手动循环读取输入流、写入输出流” 的重复逻辑，避免缓冲区管理的出错风险。

```java
// Java 8 及之前：输入流传输到输出流
  public void transfer(InputStream is, OutputStream os) throws IOException {
    byte[] buffer = new byte[1024];
    int len;
    while ((len = is.read(buffer)) != -1) {
      os.write(buffer, 0, len);
    }
    os.flush();
  }

// Java 9：输入流传输到输出流
is.transferTo (os);
```



### 7. try-with-resource 的增强 (Java 9)

> 1. **资源类对象的释放需求**
>
> 像 I/O 流（如`FileInputStream`）、网络连接（如`Socket`）、数据库连接（如`Connection`）这类资源，使用后若不及时释放会引发**资源泄漏**，导致程序性能下降甚至系统资源耗尽。
>
> 2. **try-with-resources 的核心作用**
>
> 通过声明实现`AutoCloseable`接口的资源对象，在`try`代码块执行完毕后（无论正常结束还是异常终止），**自动调用资源的`close()`方法释放资源**，替代了传统`try-catch-finally`中手动关闭资源的繁琐逻辑。



- **适用版本：** Java 9

- **解决了什么问题：** Java 7 引入的 `try-with-resources` 语法要求资源必须在 `try()` 括号内*声明*。

- **之前的解决方案 (Java 7/8)：**

  ```Java
  // 假设 in 已经在外部声明并初始化了
  InputStream in = new FileInputStream("file.txt");
  OutputStream out = new FileOutputStream("file_out.txt");
  
  // 必须在 try() 中声明一个新的、无用的变量
  try (InputStream in2 = in; OutputStream out2 = out) {
      // 使用 in2 和 out2
      in2.transferTo(out2); // (transferTo 也是 Java 9 新增的)
  }
  ```
  
- **新的解决方案 (Java 9)：** 允许在 `try()` 中使用 `final` 或*事实上的 final* (effectively final) 变量。

- **代码对比：**

  ```java
  // 之后 (Java 9)
  InputStream in = new FileInputStream("file.txt");
  OutputStream out = new FileOutputStream("file_out.txt");
  
  // 验证点：
  // 'in' 和 'out' 必须是 final 或 事实上的 final
  // (即它们在 try() 语句之前被初始化，且之后没有被修改)
  try (in; out) {  /* 此处还可以放形参传入的IO流遍了*/
      // 直接使用 in 和 out
      in.transferTo(out);
  }
  ```
  
- **面试常见问题：**

  - **Q:** Java 9 对 `try-with-resources` 做了什么改进？
  - **A:** 允许在 `try()` 括号中直接使用外部已经声明的、*事实上的 final* 资源变量，而不需要在括号内重新声明。

------



### 8. var 局部变量类型推断 (JEP 286)

- **适用版本：** Java 10

- **解决了什么问题：** Java 代码在声明变量时，类型定义过于冗长。

- **之前的解决方案 (Java 8)：**

  ```Java
  // 极其冗长的类型
  Map<String, List<Map<Integer, String>>> myMap = new HashMap<>();
  
  // 即使是用 List.of()
  List<String> list = List.of("A", "B");
  ```
  
- **新的解决方案 (Java 10)：** 使用 `var` 关键字，编译器会自动推断变量的类型。

- **代码对比：**

  ```Java
  // 之后 (Java 10)
  
  // 编译器会自动推断 myMap 的类型为 Map<String, List<...>>
  var myMap = new HashMap<String, List<Map<Integer, String>>>();
  
  // 编译器推断 list 的类型为 List<String>
  var list = List.of("A", "B");
  
  // 在 for 循环中
  for (var entry : myMap.entrySet()) {
      // entry 被推断为 Map.Entry<String, List<...>>
      var key = entry.getKey(); // key 被推断为 String
  }
  
  // 验证点 (注意事项):
  // 1. 只能用于局部变量 (方法内)
  //    public var myField = 10; // 错误：不能用于类成员
  
  // 2. 必须在声明时初始化
  //    var x; // 错误：必须初始化
  //    x = 10;
  
  // 3. 不能用于 Lambda 表达式
  //    var lambda = () -> System.out.println("Hi"); // 错误
  
  // 4. 注意 "菱形操作符" 的推断
  var dataList = new ArrayList<>(); // 警告！dataList 被推断为 ArrayList<Object>
  var stringList = new ArrayList<String>(); // 正确
  ```
  
- **面试常见问题：**

  - **Q:** `var` 关键字是什么？
  - **A:** 它是 Java 10 引入的局部变量类型推断。它不是一个新的“关键字”，而是一个保留的类型名。编译器在编译时会根据右侧的初始化表达式自动推断出变量的*静态类型*。
  - **Q:** `var` 会让 Java 变成动态语言吗？
  - **A:** 不会。Java 仍然是强类型的静态语言。`var` 只是一个“语法糖”，它在编译时（`.java` -> `.class`）就会被替换成真实的类型。
  - **Q:** `var` 有什么使用限制？
  - **A:** 只能用于局部变量；必须在声明时初始化；不能用于类成员、方法参数、方法返回值。

------

| 对比维度   | Java 的`var`                                                 | JavaScript 的`var`                                           |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语言定位   | 局部变量类型推断关键字（语法糖），不改变 Java 强类型本质     | 变量声明关键字，体现 JavaScript 弱类型 / 动态类型特性        |
| 类型处理   | 编译时由初始化值推断类型，类型一旦确定不可变，后续赋值必须匹配类型 | 运行时类型由值决定，类型可动态改变（同一变量可赋值不同类型） |
| 作用域     | 仅作用于局部变量（方法内、代码块内），遵循块级作用域         | 函数级作用域（无块级作用域），函数内声明的变量在整个函数内有效 |
| 适用场景   | 仅能声明局部变量，不能用于类成员变量、方法参数、返回值等     | 可声明全局变量、函数内变量等所有场景                         |
| 变量提升   | 不存在，变量必须声明后才能使用                               | 存在（声明提升到作用域顶部，赋值不提升），可在声明前访问（值为`undefined`） |
| 重复声明   | 同一作用域内不允许重复声明，会导致编译错误                   | 同一作用域内允许重复声明，后声明会覆盖前一次                 |
| 初始化要求 | 必须初始化（否则无法推断类型），如`var x = 10;`合法，`var x;`不合法 | 可以不初始化，如`var x;`合法（默认值为`undefined`）          |



### Java 钻石操作符（<>）的版本演进解析

#### 1. Java 7：引入钻石操作符（核心功能）

- **作用**：在泛型构造函数调用时，可**省略泛型类型参数**，编译器会根据等号左边的变量声明**自动推断泛型类型**。

- **代码示例**：

  ```java
  // Java 7 前写法
  List<String> list = new ArrayList<String>();
  // Java 7 及后简化写法
  List<String> list = new ArrayList<>(); // 编译器自动推断泛型为 String
  ```

#### 2. Java 8：存在限制（匿名内部类不可用）

- **限制**：钻石操作符**不能用于匿名内部类**，否则编译报错。

- **代码示例（不合法）**：

  ```java
  // Java 8 中编译错误
  Comparator<String> comp = new Comparator<>() { // 匿名内部类使用 <> 会报错
      @Override
      public int compare(String o1, String o2) {
          return o1.length() - o2.length();
      }
  };
  ```

#### 3. Java 9：解除匿名内部类限制

- **改进**：如果编译器能从上下文**推断出泛型类型**，匿名内部类也可使用钻石操作符。

- **代码示例（合法）**：

  ```java
  // Java 9 及后合法写法
  Comparator<String> comp = new Comparator<>() { // 匿名内部类可正常使用 <>
      @Override
      public int compare(String o1, String o2) {
          return o1.length() - o2.length();
      }
  };
  ```

#### 总结

钻石操作符的演进体现了 Java 对泛型类型推断的逐步优化：Java 7 简化了常规泛型对象的创建，Java 9 进一步解除了匿名内部类的限制，让代码更简洁的同时，保持了类型安全性。



### 9. HttpClient API 标准化 (JEP 321)

- **适用版本：** Java 9 (孵化), Java 11 (正式标准化)

- **解决了什么问题：**

  1. Java 原生的 `HttpURLConnection` API 古老、难用、阻塞式且功能有限。
  2. 开发者被迫使用第三方库 (如 Apache HttpClient, OkHttp)。
  3. 缺乏对 HTTP/2 和 WebSocket 的原生支持。

- **之前的解决方案：** `HttpURLConnection` 或 引入 Apache/OkHttp 库。

- **新的解决方案：** `java.net.http` 包，提供了全新的 API。

  - 支持 HTTP/1.1 和 **HTTP/2** (默认)。
  - 支持 **WebSocket**。
  - 支持**异步**和**非阻塞** I/O (基于 `CompletableFuture`)。
  - API 采用链式调用 (Builder 模式)，更现代、更易用。

- **代码对比：**

  - **之前 (HttpURLConnection)：** (繁琐，阻塞，难用)

    ```Java
    // (省略了大量 try-catch 和 error handling)
    URL url = new URL("http://www.baidu.com");
    HttpURLConnection con = (HttpURLConnection) url.openConnection();
    con.setRequestMethod("GET");
    con.setRequestProperty("Accept", "application/json");
    con.setConnectTimeout(5000);
    
    try (BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
        String line;
        StringBuilder content = new StringBuilder();
        while ((line = in.readLine()) != null) {
            content.append(line);
        }
        System.out.println(content.toString());
    } finally {
        con.disconnect();
    }
    ```
    
  - **之后 (Java 11 HttpClient)：**

    ```Java
    // 1. 创建 Client
    HttpClient client = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2) // 默认 HTTP/2
            .connectTimeout(Duration.ofSeconds(5))
            .build();
    
    // 2. 创建 Request
    HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://api.example.com/data"))
            .GET() // 链式调用
            .build();
    
    // 验证点 1：同步 (send)
    try {
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        System.out.println("Status code: " + response.statusCode());
        System.out.println("Body: " + response.body());
    
    } catch (Exception e) {
        e.printStackTrace();
    }
    
    // 验证点 2：异步 (sendAsync)，返回 CompletableFuture
    client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
          .thenApply(HttpResponse::body) // 获取 body
          .thenAccept(System.out::println) // 打印
          .join(); // (在 main 方法中等待异步完成)
    
    Thread.sleep(10000); //防止 thenApply 后台的forkJoin线程池关闭
    ```
  
- **面试常见问题：**

  - **Q:** 为什么 Java 11 要引入一个新的 HttpClient？
  - **A:** 旧的 `HttpURLConnection` API 太过时，不支持 HTTP/2 和异步。新的 `java.net.http.HttpClient` 提供了现代、易用、支持 HTTP/2 和 WebSocket、并原生支持异步非阻塞的 API。

------

### Java 11 单文件源代码程序特性解析

#### 1. 核心描述

Java 11 支持直接运行**单个.java 文件**，无需显式执行`javac`编译操作。编译器会在内存中完成编译并执行，自动处理字节码的生成与运行流程。

#### 2. 设计目的

简化初学者学习和编写 Java 小脚本的过程，让 Java 程序实现 “编写即运行” 的轻量化体验，降低语言入门门槛。

#### 3. 使用方式

- 编写单文件 Java 程序（如`Hello.java`）：

  ```java
  public class Hello {
      public static void main(String[] args) {
          System.out.println("Hello Java 11!");
      }
  }
  ```

- 直接通过`java`命令运行：

  ```bash
  java Hello.java
  ```

  无需先执行

  ```
  javac Hello.java
  ```

  编译步骤，编译器在内存中自动完成编译并执行程序。

#### 4. 背景与价值

传统 Java 开发需经历 “编写→编译（`javac`）→运行（`java`）” 三步，该特性省去了显式编译环节，让开发者可快速验证代码逻辑。它适用于小脚本、学习 Demo 等场景，同时保留了 Java 强类型、编译期检查的优势，是 Java 在 “易用性” 方向的重要优化。



### JShell 交互式编程工具解析

#### 1. 核心定位

JShell 是 Java 9 首次引入的**交互式编程工具（REPL，Read-Eval-Print Loop）**，属于 Java 的 “即时代码片段执行环境”。

#### 2. 功能特点

- 支持**即时输入并执行 Java 代码片段**，无需编写完整类或方法，可直接定义变量、计算表达式、编写方法等。
- 输入代码后立即返回执行结果，实现 “编写即运行” 的交互式体验。

#### 3. 适用场景

- **快速测试**：验证代码逻辑、API 用法（如测试集合操作、Stream 方法等）。
- **学习语法**：尤其是 Java 新特性（如 Lambda、模块系统等），降低入门门槛。
- **原型验证**：快速搭建代码原型，确认逻辑可行性。
- 注意：因缺乏工程化结构，**不建议在生产环境使用**。

#### 4. 背景与价值

在 JShell 出现前，Java 是 “编译 - 运行” 的非交互式语言，开发流程相对繁琐。JShell 的引入让 Java 具备了类似 Python、JavaScript 的交互式体验，填补了 Java 在 “快速验证、语法学习” 场景的短板，大幅提升了开发者的调试与学习效率。



### 低延迟垃圾回收器：Epsilon 解析

##### 1. 核心目标

提供 “无操作（no-op）” 垃圾回收器，仅负责内存分配，**不执行任何垃圾回收动作**。设计初衷并非用于生产环境，而是作为**性能基准测试工具**和低延迟场景的 “对照组”，用于衡量无 GC 干扰时的应用极限性能。

##### 2. 核心特性

- **内存分配与回收**：仅负责内存分配，当 JVM 堆内存耗尽时直接退出，抛出`OutOfMemoryError`。
- **GC 停顿**：完全不执行垃圾回收，因此**无 GC 停顿**，可用于量化 “无 GC 干扰” 下的应用性能上限。
- **设计优势**：实现体积小、代码简单，便于开发者理解 GC 底层机制，或作为**自定义 GC 的基础模板**。

##### 3. 背景与价值

Epsilon 是 Java 针对 “低延迟场景性能基准测试” 和 “GC 原理学习” 的特殊设计：

- 对于性能测试，它提供了 “无 GC 开销” 的基准线，可用于对比其他 GC（如 G1、ZGC）的性能损耗；
- 对于 GC 原理学习，其极简的实现让开发者能快速理解内存分配与回收的核心逻辑，降低了 GC 源码的学习门槛。



### 低延迟垃圾回收器：ZGC 解析

#### 1. 与 Epsilon 的核心区别

| 对比维度     | Epsilon 垃圾回收器                       | ZGC 垃圾回收器                       |
| ------------ | ---------------------------------------- | ------------------------------------ |
| 定位         | 无操作回收器，仅用于测试 / 性能基准      | 用于生产场景的低延迟回收器           |
| 垃圾回收行为 | 不执行任何垃圾回收，堆内存耗尽时直接退出 | 执行高效垃圾回收，目标是亚毫秒级停顿 |

#### 2. ZGC 版本演进（按 JDK 版本）

| 版本   | 状态     | 核心改进                           | 重要特性                                                     |
| ------ | -------- | ---------------------------------- | ------------------------------------------------------------ |
| JDK 11 | 实验特性 | 初始版本                           | 并发标记、并发转移                                           |
| JDK 12 | 实验特性 | 支持并发类卸载                     | 缩短停顿时间                                                 |
| JDK 13 | 实验特性 | 最大堆大小扩展到 16TB              | 释放内存归还操作系统                                         |
| JDK 14 | 生产就绪 | macOS 和 Windows 支持              | `-XX:+UseZGC` 直接启用                                       |
| JDK 15 | 标准特性 | 正式生产可用                       | 并发栈处理                                                   |
| JDK 16 | 标准特性 | 并发线程栈处理                     | 性能优化                                                     |
| JDK 17 | 标准特性 | 动态分代大小调整                   | 新的分代收集策略                                             |
| JDK 21 | 标准特性 | **分代式 ZGC**                     | 独立年轻代和老年代收集                                       |
| JDK 22 | 标准特性 | 分代模式优化与虚拟线程协同适配     | 提升分代回收吞吐量，初步支持与虚拟线程的内存管理协同         |
| JDK 23 | 标准特性 | 切换分代模式为默认配置             | 无需指定 `-XX:+ZGenerational`，标记非分代模式为废弃，降低维护成本 |
| JDK 24 | 标准特性 | 移除非分代模式，强化分代模型稳定性 | 分代模式成为唯一选项，优化大堆性能，GC 停顿压缩至毫秒级      |
| JDK 25 | 标准特性 | 分代模型细节优化                   | 完善跨代引用管理，提升与结构化并发的兼容性，优化运维监控能力 |

#### 3. 核心价值与适用场景

- **低延迟优势**：ZGC 致力于实现亚毫秒级 GC 停顿，适用于**高响应要求的生产场景**，如金融交易系统、实时数据服务、低延迟网络应用等。
- **版本演进意义**：从 JDK 11 的实验特性逐步迭代，到 JDK 24 后分代模式成为唯一选项，体现了其在性能、兼容性、运维友好性上的持续优化，最终成为大堆场景下低延迟 GC 的优选方案。



> 理解 “低延迟” 和 “分代” 这两个概念，是理解现代垃圾回收器（如 ZGC、Shenandoah）如何工作的关键。用一个简单的比喻：打扫房间。

#### 一、低延迟

- **传统 GC（如 JDK 8 之前的 Parallel GC）**：采用 “Stop-The-World” 机制，即停止所有应用程序线程，进行完整的垃圾回收。

  > 类比：你正在书房里专心工作，但为了打扫整个房子，必须停止手头的一切工作，然后把所有房间从里到外彻底打扫一遍。这个过程可能持续几个小时，期间完全无法工作。

- **低延迟 GC（如 ZGC、Shenandoah）**：无需停止工作，保洁人员会悄悄地、一点一点地打扫，几乎感觉不到他们的存在。

#### 二、分代

- **分代原理**：不同物品，不同对待。
- **分代的优化策略**：基于**弱代假说**，包含两个核心观察：
  1. **绝大多数对象都是 “朝生夕死” 的（**分配后很快就不再使用）
  2. 熬过多次垃圾回收的对象，通常会继续存活很久
- **打扫房间的类比**：
  - **年轻代** = 你正在使用的书桌
    - 特点：非常杂乱，但大部分都是废纸、零食包装等很快要扔的东西
    - 策略：频繁、快速地清理桌面（Minor GC）
  - **老年代** = 书柜和储物间
    - 特点：相对整洁，存放的是书籍、重要文件等长期需要的物品
    - 策略：较少、彻底地整理（Major GC/Full GC）

#### 三、内存结构示意图说明

| 区域       | 说明                                  |
| ---------- | ------------------------------------- |
| Eden       | 年轻代的 “伊甸园”，新对象优先分配区域 |
| S0、S1     | Survivor 区，用于对象存活标记与转移   |
| Tenured    | 老年代，存放长期存活的对象            |
| Meta space | 元空间，存储类元数据等信息            |

![image-20251118021140931](C:\Users\gouwe\Desktop\images\新特性\image-20251118021140931.png)

> **S0、S1（Survivor 区的两个子区域）解析**
>
> 在 Java 垃圾回收的**年轻代**中，S0 和 S1 是两个**Survivor 子区域**，与 Eden 区共同组成年轻代的内存结构，核心作用是通过**复制算法**管理对象的 “存活周期”，减少内存碎片并控制对象晋升老年代的逻辑。
>
> 1. **角色定位**
>
> 年轻代分为三个区域：**Eden 区**（新对象优先分配区）、**S0**、**S1**（两个 Survivor 区，默认各占年轻代的 1/8）。S0 和 S1**交替使用**，用于在 **YGC（年轻代垃圾回收）** 时保存存活的对象，并通过 “复制 - 年龄递增” 的逻辑筛选出需要晋升老年代的对象。
>
> 2. **工作机制（YGC 流程）**
>
> - 步骤 1：YGC 触发时，**Eden 区 + 其中一个 Survivor 区（如 S0）** 的存活对象，会被**复制到另一个 Survivor 区（如 S1）**。
> - 步骤 2：在复制过程中，存活对象的 **“年龄计数器” 加 1**；若年龄达到阈值（默认 15），则直接**晋升到老年代**。
> - 步骤 3：下一次 YGC 时，**Eden 区 + 现在的 S1 区**的存活对象，会被复制到**S0 区**—— 以此类推，S0 和 S1 交替作为 “源区域” 和 “目标区域”。
>
> 3. **设计意义**
>
> - 避免内存碎片：通过复制算法，存活对象会被紧凑地复制到新区域，减少内存碎片。
> - 控制晋升逻辑：通过年龄计数器，精准筛选出 “长期存活的年轻对象”，避免频繁晋升对老年代的压力。
> - 高效回收：仅需复制存活对象，大幅提升 YGC 的效率（死亡对象占年轻代的绝大多数）。
>
> 简言之，S0 和 S1 是年轻代垃圾回收的 “临时缓冲区”，通过交替复制的机制，既保证了对象存活周期的管理，又实现了高效的内存回收。



> **流程说明**
>
> 1. **对象分配阶段**：新对象申请时，优先判断 Eden 区是否有空间，有则直接分配；无则触发年轻代垃圾回收（YGC）。
> 2. **YGC 触发后**：再次判断 Eden 区是否有空间，有则分配；无则区分是否为超大对象 —— 超大对象直接尝试分配到老年代（Old 区），非超大对象也尝试分配到 Old 区；若 Old 区无空间则触发 Full GC（FGC），FGC 后 Old 区仍无空间则抛出 OOM。
> 3. **YGC 内部流程**：回收时判断 Survivor 区空间，有空间则将对象放入 S0/S1 区域；若对象存活超过阈值或 Survivor 区无空间，则对象晋升老年代。

#### 现代 GC 的演进方向解析

| 代别   | 核心特征       | 代表 GC                      | 特点总结                                                     |
| ------ | -------------- | ---------------------------- | ------------------------------------------------------------ |
| 第一代 | 分代但不低延迟 | Parallel GC、CMS             | 采用分代假设优化回收效率，但老年代收集仍存在明显停顿，无法满足低延迟场景需求 |
| 第二代 | 低延迟但不分代 | ZGC（JDK 11-20）、Shenandoah | 实现亚毫秒级停顿，保障低延迟特性，但初期未利用分代假设，吞吐量优化有限 |
| 第三代 | 低延迟 + 分代  | ZGC（JDK 21+）、G1           | 结合两者优势，既实现极低的停顿时间，又通过分代假设提升回收吞吐量，是现代 GC 的主流演进方向 |



#### **面试常见问题：**

- **Q:** 什么是 ZGC？它的主要目标是什么？
- **A:** ZGC (Z 垃圾回收器) 是一款可扩展的、并发的、低延迟 GC。它的主要目标是将 STW 停顿时间控制在个位数毫秒 (ms) 以内，且停顿时间不随堆内存的增大而增加。
- **Q:** ZGC 为什么能做到这么低的延迟？
- **A:** (深入) 它通过使用“有色指针”和“读屏障”技术，使得 GC 的绝大部分工作（如标记、整理）都可以和应用线程并发执行，从而极大地减少了 STW。
- **Q:** 什么是 Epsilon GC？它有什么用？
- **A:** 它是一个“无操作”(No-Op) GC，只分配内存，不回收。用于性能测试或内存压力测试，以排除 GC 对结果的干扰。

------



### 15、默认启用 TLS 1.3

TLS 1.3 是 TLS 协议（Transport Layer Security 传输层安全性协议）的最新版本，相比 TLS 1.2 有**更快的握手速度**（减少 1 个 RTT 往返）和**更强的加密安全性**（移除 RC4、SHA-1 等弱算法）。Java 11 将 TLS 1.3 设为默认启用，同时保留对 TLS 1.2 及以下版本的兼容。

#### 谁最该拥抱这个变化？

1. **高并发服务：服务器资源省一半：**在电商秒杀、API 网关等场景，TLS 握手是 CPU 的主要消耗源。TLS 1.3 的会话复用技术（通过 Session Tickets）能让重复连接跳过完整握手，服务器 CPU 和内存占用可降低 30%-50%。配合 AES-NI 硬件加速，加密速度能提升 5-10 倍。
2. **移动应用：用户体验显著提升：**移动端网络波动大，延迟每降低 100ms，用户留存率可提升 2%。TLS 1.3 的 1-RTT 握手能让 App 启动时的接口请求快 200ms 以上，0-RTT 更能实现 “秒开” 体验。
3. **合规需求：满足最新安全标准：**金融、政务等领域的合规检查（如 PCI DSS）已要求禁用 TLS 1.0/1.1，未来可能强制启用 TLS 1.3。Java 11 的默认配置可直接满足合规要求，避免整改风险。

#### TLS 1.2 和 TLS 1.3 特性对比

| 特性     | TLS 1.2                           | TLS 1.3                                                |
| -------- | --------------------------------- | ------------------------------------------------------ |
| 握手速度 | ⚠️ 通常需要 2 个 RTT               | ✅ 通常只需 1 个 RTT（0-RTT 可选）                      |
| 密钥交换 | 支持多种（包括不安全的 RSA）      | 仅支持前向安全的密钥交换（如 DH、ECDH）                |
| 加密算法 | 支持大量老旧算法（如 RC4, SHA-1） | 移除所有不安全的算法，强制使用认证加密（AEAD）         |
| 密码套件 | 结构复杂，可协商各个组件          | 结构简化，大部分组件已固定，只需协商密钥交换和签名算法 |
| 握手过程 | 支持重协商，过程相对冗长          | 简化且加密更多，ServerHello 后全部加密                 |
| 安全性   | 依赖正确配置以避免不安全选项      | 内置安全，移除了已知的安全风险                         |

> **Rtt 是 Round-Trip Time 的缩写，中文译为 “往返时间”**，指数据从发送方发出，到被接收方接收并返回响应，整个过程的时间（单位通常为毫秒）。
>
> 它是衡量网络延迟的关键指标，直接影响通信效率：
>
> - 在 TLS 协议中，TLS 1.2 握手通常需要**2 个 RTT**（数据往返两次），而 TLS 1.3 优化后只需**1 个 RTT**，大幅提升了握手速度；
> - 对用户体验而言，RTT 越低，网络交互的 “延迟感” 越弱（比如移动端 App 接口请求、网页加载的响应速度）。



### 16、增强密码学算法支持

- 新增对 **ChaCha20-Poly1305** 加密算法的支持（用于替代 AES 在某些场景下的应用）；
- 增强 **ECDSA**（椭圆曲线数字签名算法 Elliptic Curve Digital Signature Algorithm）签名算法的性能，支持更大的密钥长度；
- 移除对「弱加密算法」的默认支持（如 3DES、RC4），需手动启用（不推荐）。

> **为什么要新增对 ChaCha20-Poly1305 的支持？**
>
> 替代并非全面取代，而是在特定场景下的优先选择。AES 由于其标准化和广泛的硬件支持，仍然是加密领域的 “黄金标准” 和默认选择。

1. **性能优势（尤其在缺乏 AES 硬件加速的环境中）**这是最核心的原因。

   - **AES**：作为分组密码，其速度优势**严重依赖于 CPU 的 AES-NI 指令集**。在支持 AES-NI 的现代 x86 服务器和桌面电脑上，AES 速度极快。
   - **ChaCha20**：是一种流密码，其设计主要基于 ARX（加法、循环移位、异或）操作。这些操作是所有通用 CPU 都擅长处理的基本指令，**不需要专门的硬件加速。**

   因此，**在以下环境中，ChaCha20 的性能远超 AES**：

   - 移动设备：许多旧的或中低端的手机 / 平板 CPU 没有集成 AES 硬件加速。
   - 嵌入式系统：路由器、IoT 设备等。
   - 旧的服务器硬件。

   Google 的测试表明，在缺乏 AES-NI 的设备上，ChaCha20-Poly1305 比 AES-GCM 快三到四倍。

2. **对侧信道攻击的抵抗力更强**

   - 侧信道攻击：攻击者不是直接攻击算法本身，而是通过分析算法的物理实现信息来破解密钥，例如执行时间、功耗、电磁辐射等。
   - **AES**的实现（尤其是基于查表的软件实现）容易受到缓存计时攻击等侧信道攻击的威胁。
   - **ChaCha20**的**算法**结构**恒定时间**更容易实现。它的操作与数据无关，执行时间恒定，因此天生对计时攻击等侧信道攻击有更强的抵抗力。

**3. 简化与降低错误率**

- **AES-GCM**：实现相对复杂，若使用不当（如重复使用 Nonce）会导致灾难性安全失败；GCM 模式对硬件加速依赖较高以实现最佳性能。
- **ChaCha20-Poly1305**：设计更简单、一体化，将加密（ChaCha20）和认证（Poly1305）通过同一密钥派生紧密结合，降低了实现和使用的复杂性，从而减少误用风险。

#### 

| 特性     | AES                       | ChaCha20                                      |
| -------- | ------------------------- | --------------------------------------------- |
| 类型     | 分组加密                  | 流加密                                        |
| 性能     | 在有硬件加速的 CPU 上极快 | 在软件实现中通常更快（尤其无 AES 硬件加速时） |
| 安全性   | 极强，是行业黄金标准      | 极强，被认为是 AES 的可靠替代品               |
| 抗侧信道 | 实现不当可能受影响        | 天生抵抗力更强                                |
| 普及度   | 极高，是默认选择          | 很高，是现代系统的首选替代                    |



### 为什么废弃 DES、3DES、RC4？

#### 1. DES

- 全称：数据加密标准
- 类型：对称、分组加密
- 密钥长度：56 位（已过时）
- 现状：已彻底被破解，绝对不安全。早在 1999 年就能在 24 小时内被暴力破解，不应在任何新系统中使用。
- 历史意义：现代密码学的开创者，现仅用于学习密码学历史。

#### 2. 3DES

- 全称：三重数据加密算法
- 原理：作为 DES 到 AES 的过渡方案，对每个数据块应用三次 DES 加密（加密 - 解密 - 加密）。
- 密钥长度：有效密钥长度为 112 或 168 位。
- 现状：已弃用。虽然比 DES 安全，但速度慢，且 NIST 已于 2017 年宣布将其淘汰，现代系统中不应使用。

#### 3. RC4（Rivest Cipher 4）

- 类型：对称加密、流密码
- 特点：曾以速度极快和实现简单而闻名。
- 致命缺陷：算法本身存在严重的统计偏差，密钥流不是真随机。
- 现状：已被彻底攻破，在所有现代系统中被禁用和弃用。



> ECDSA（椭圆曲线数字签名算法）解析

**核心定义与安全性**

ECDSA 是基于**椭圆曲线密码学**的强大数字签名标准，通过巧妙的数学原理，实现了 “短密钥提供高安全性” 的目标，成为现代安全协议和系统（尤其是区块链技术）中数字签名的事实首选算法。其安全性核心依赖于**椭圆曲线离散对数问题的难度**和**随机数生成器的质量**。

**实际应用场景**

ECDSA 广泛应用于资源受限或高性能需求的场景：

- **加密货币**：比特币、以太坊等使用 ECDSA（曲线 secp256k1）来签署交易，证明资产所有权。
- **TLS/SSL 证书**：现代网站证书广泛使用 ECDSA 替代 RSA，提供更快的握手速度。
- **SSH**：用于认证客户端和服务器端，保障远程连接的身份可信性。
- **软件分发**：用于签署软件更新，确保用户下载的软件来自可信来源且未被篡改。
- **政府文件**：许多国家的电子身份证和数字护照使用 ECDSA，实现身份的数字可信认证。



## Java 12-17 新特性概述

以下是明确要求java17的主力Java框架和组件

| 框架 / 组件      | 起始版本 | 最低 Java 要求 | 说明                                                         |
| ---------------- | -------- | -------------- | ------------------------------------------------------------ |
| Spring Boot      | 3.0.x    | Java 17        | 生态核心驱动，强制要求                                       |
| Spring Framework | 6.0.x    | Java 17        | Spring Boot 3 的基础，强制要求                               |
| Quarkus          | 3.0.x    | Java 17        | 云原生框架，强制要求                                         |
| Micronaut        | 4.0.x    | Java 17        | 云原生框架，强制要求                                         |
| Jakarta EE       | 11       | Java 17        | 未来版本，目前 10 仍要求 Java 11                             |
| Hibernate ORM    | 6.0.x    | Java 11        | 但要与 Spring Boot 3 等搭配，需 Java 17                      |
| Gradle           | 7.3+     | Java 17        | 7.0 要求 Java 16，7.3 要求 Java 17                           |
| Maven            | 3.9.x    | Java 17        | 虽然 Maven 3.8.x 可兼容 Java 17，但 Maven 3.9.0 起对 Java 17 的支持更完善，且未来版本将逐步放弃对低版本 JDK 的支持。 |
| JUnit            | 5.10+    | Java 17        | JUnit 5.10 起将最低 JDK 版本提升至 Java 17                   |
| logback          | 1.5.x    | Java 17        | 1.5.x 及以上进一步优化了对 Java 17 模块系统的支持，且官方推荐在 Java 17 环境使用 |



新特性总览

| JDK 版本 | 特性                          | 特性类型 | 演进说明                         |
| -------- | ----------------------------- | -------- | -------------------------------- |
| JDK 12   | Switch 表达式                 | 预览特性 | JDK 13 二次预览，JDK 14 成为标准 |
|          | Shenandoah 垃圾回收器         | 实验特性 | JDK 15 成为标准                  |
|          | JVM 常量 API                  | 标准特性 |                                  |
|          | 微基准测试套件                | 标准特性 |                                  |
|          | G1 垃圾回收器改进             | 标准特性 |                                  |
| JDK 13   | 文本块 (Text Blocks)          | 预览特性 | JDK 14 二次预览，JDK 15 成为标准 |
|          | Switch 表达式 (再次预览)      | 预览特性 | JDK 14 成为标准                  |
|          | 动态 CDS 归档                 | 标准特性 |                                  |
|          | ZGC 增强                      | 标准特性 |                                  |
|          | 重构 Socket API               | 标准特性 |                                  |
| JDK 14   | 记录类 (Record)               | 预览特性 | JDK 16 成为标准                  |
|          | instanceof 模式匹配           | 预览特性 | JDK 16 成为标准                  |
|          | 打包工具 (jpackage)           | 孵化特性 | JDK 16 成为标准                  |
|          | NullPointerException 提示改进 | 标准特性 |                                  |
| JDK 15   | 密封类 (Sealed Classes)       | 预览特性 | JDK 17 成为标准                  |
|          | 隐藏类                        | 标准特性 | 面向框架和库开发者的高级特性     |
| JDK 16   | instanceof 模式匹配           | 标准特性 |                                  |
|          | 记录类 (Record)               | 标准特性 |                                  |
|          | 打包工具 (jpackage)           | 标准特性 |                                  |
| JDK 17   | 密封类 (Sealed Classes)       | 标准特性 |                                  |
|          | Switch 模式匹配               | 预览特性 |                                  |



### 14. Switch 表达式 (JEP 361)

新switch表达式解决了传统switch语句冗长、易出错（如穿透问题）的痛点，具备以下关键特性：
1. **箭头标签**
   - 语法为`case 常量值 ->`，标签匹配时仅执行箭头右侧的表达式或代码块。
   - 核心优势是**无穿透风险**，无需手动写`break`，从根源上避免因遗漏`break`导致的逻辑错误，提升代码健壮性。
2. **多case合并**
   可通过逗号将多个`case`标签合并，使代码结构更紧凑，减少冗余，提升可读性。
3. **作为表达式返回值**
   传统`switch`是语句（不产生值），新`switch`是表达式（可产生值），可直接将其结果赋值给变量（如`String weekName = switch (week) { ... }`），增强语法表达力。
4. **yield关键字**
   当箭头右侧是复杂代码块（用`{}`包裹）时，需用`yield`关键字返回值，其作用类似`return`，专门用于switch表达式内部，保证复杂逻辑下的返回确定性。



- **适用版本：** Java 12 (预览), Java 14 (转正)

- **解决了什么问题：**

  1. **语法繁琐：** 传统的 `switch` 语句需要写大量的 `case ... :` 和 `break;`。
  2. **容易出错 (Fall-through)：** 忘记写 `break` 会导致“穿透”到下一个 `case`，这是常见的 Bug 来源。
  3. **只是“语句”(Statement)：** 传统的 `switch` 只能执行动作，不能作为“表达式”(Expression) 返回一个值。你必须先声明一个外部变量，然后在 `case` 内部给它赋值。

- **之前的解决方案 (Java 8)：**

  ```Java
  // 必须先声明一个变量
  int numLetters;
  Day day = Day.WEDNESDAY;
  
  switch (day) {
      case MONDAY:
      case FRIDAY:
      case SUNDAY:
          numLetters = 6;
          break; // 必须写 break
      case TUESDAY:
          numLetters = 7;
          break;
      case THURSDAY:
      case SATURDAY:
          numLetters = 8;
          break;
      case WEDNESDAY:
          numLetters = 9;
          break;
      default:
          throw new IllegalStateException("Invalid day");
  }
  ```
  
- **新的解决方案 (Java 14+)：**

  1. **作为表达式，可返回值。**
  2. 使用 `->` 箭头语法，**不再需要 `break`** (不会穿透)。
  3. 支持 `yield` 关键字在代码块中返回值。
  4. `case` 允许写多个标签。

- **代码对比：**

  ```Java
  Day day = Day.WEDNESDAY;
  
  // 验证点 1：使用 -> 箭头语法 和 表达式
  int numLetters = switch (day) {
      case MONDAY, FRIDAY, SUNDAY -> 6;
      case TUESDAY                -> 7;
      case THURSDAY, SATURDAY     -> 8;
      case WEDNESDAY              -> 9;
      // default 也是必须的（除非 switch 覆盖了所有枚举）
      // 这里假设 Day 是一个枚举，如果不是，则 default 必须
  }; // 注意这里有分号
  
  System.out.println(numLetters); // 9
  
  // 验证点 2：使用 yield 在复杂代码块中返回值
  // (假设逻辑比较复杂，不能用 ->)
  int result = switch (day) {
      case MONDAY:
          System.out.println("今天是周一");
          yield 1; // 使用 yield 返回值
      case TUESDAY:
          System.out.println("今天是周二");
          yield 2;
      default:
          System.out.println("其他日子");
          yield 0;
  };
  ```
  
- **面试常见问题：**

  - **Q:** 新的 Switch 表达式和旧的 Switch 语句有什么区别？
  - **A:** 1. 新的可以作为*表达式*并返回值。 2. 使用 `->` 语法时，不再需要 `break`，避免了穿透。 3. `case` 后面可以跟多个值，用逗号隔开。 4. 引入 `yield` 关键字用于在 `case` 代码块中返回值。
  - **Q:** `yield` 和 `return` 有什么区别？
  - **A:** `return` 用于从方法中退出并返回值。`yield` 用于从 `switch` 表达式的 `case` 块中返回值。

------



### 15. instanceof 模式匹配 (JEP 394)



- **适用版本：** Java 14 (预览), Java 16 (转正)

- **解决了什么问题：** 极其常见的一种啰嗦写法：先用 `instanceof` 检查类型，再强制类型转换为该类型，然后才能使用。

- **之前的解决方案 (Java 8)：**

  ```java
  Object obj = "Hello Java 16";
  
  if (obj instanceof String) {
      // 1. 检查
      String s = (String) obj; // 2. 强转
      // 3. 使用
      if (s.length() > 5) {
          System.out.println(s.toUpperCase());
      }
  }
  ```
  
- **新的解决方案 (Java 16+)：** 在 `instanceof` 检查为 `true` 时，直接声明一个该类型的新变量并自动完成转型。

- **代码对比：**

  ```java
  Object obj = "Hello Java 16";
  
  // 验证点 1：
  // 如果 obj 是 String，则自动转型为 s
  if (obj instanceof String s) {
      // 's' 已经转型，可以直接使用
      // 作用域被限制在 if(true) 块内
      if (s.length() > 5) {
          System.out.println(s.toUpperCase()); // HELLO JAVA 16
      }
  }
  
  // 验证点 2：在 && 和 || 中的智能作用域
  if (obj instanceof String s && s.length() > 5) {
      // s 可以在 && 符号右侧直接使用
      System.out.println(s.toLowerCase());
  }
  ```
  
- **面试常见问题：**

  - **Q:** 什么是 `instanceof` 模式匹配？
  - **A:** 它简化了类型检查和转换的模板代码。如果 `obj instanceof String s` 为 `true`，它会自动将 `obj` 转换为 `String` 类型并赋值给新变量 `s`，`s` 的作用域仅限于 `if` 块或 `&&` 表达式的后续部分。
  - **Q:** 那个新变量 `s` 的作用域是怎样的？
  - **A:** 它的作用域被智能地限制在*类型检查为真*才能访问到的地方。例如，在 `if (obj instanceof String s)` 中，`s` 仅在 `if` 块内可用。在 `if (!(obj instanceof String s))` 中，`s` 反而在 `else` 块中可用。

------



### 16. 文本块 (Text Blocks) (JEP 378)

- **适用版本：** Java 13 (预览), Java 15 (转正)

- **解决了什么问题：** 在 Java 中编写多行字符串（如 SQL、JSON、HTML、XML）是一场噩梦。你需要大量的 `+` 拼接符、`\n` 换行符和 `\"` 转义符。

- **之前的解决方案 (Java 8)：**

  ```java
  // 难以编写，难以阅读
  String json = "{\n" +
                "  \"name\": \"Gemini\",\n" +
                "  \"type\": \"AI\",\n" +
                "  \"features\": [\n" +
                "    \"Notes\", \"Lists\"\n" +
                "  ]\n" +
                "}";
  ```
  
- **新的解决方案 (Java 15+)：** 使用 `"""` (三个双引号) 开始和结束。

- **代码对比：**

  ```Java
  // 之后 (Java 15)
  
  // 验证点 1：使用 """
  // 开始的 """ 后面必须跟一个换行符
  String json = """
                {
                  "name": "Gemini",
                  "type": "AI",
                  "features": [
                    "Notes", "Lists"
                  ]
                }
                """; // 结束的 """ 可以在同一行或新行
  
  // 验证点 2：智能的缩进管理
  // 编译器会自动去除“共同”的左侧空白。
  // 以上面为例，"{" 和 "}" 对齐，它们就是内容缩进的基线。
  
  // 验证点 3：不需要转义 "
  // （除非你连续写了3个 "）
  
  // 验证点 4： SQL 示例
  String sql = """
               SELECT id, name, email
               FROM user
               WHERE department = 'Sales'
               ORDER BY name;
               """;
  ```
  
- **面试常见问题：**

  - **Q:** 什么是文本块？
  - **A:** 它是 Java 15 引入的多行字符串字面量，以 `"""` 开始和结束。
  - **Q:** 它有什么好处？
  - **A:** 1. 编写多行字符串（如 JSON, SQL）时不再需要 `+` 拼接和 `\n` 换行。 2. 字符串内的 `"` (双引号) 不再需要转义。 3. 它会自动处理和去除公共的“前导缩进”，使代码在保持格式美观的同时，字符串内容本身不会包含多余的空格。

------



### 17. 记录类 (Records) (JEP 395)

#### 1. 核心概念与背景

- **适用版本**：Java 14 (预览), **Java 16 (正式转正)**

- **核心目的**：解决创建简单的“数据载体”类（DTOs, POJOs）时，开发者需要编写海量样板代码 (Boilerplate) 的痛点。

- **基本语法**：

  ```Java
  public record 记录类名(实例变量列表) {
      // 可选：额外的方法、静态变量、构造函数校验等
  }
  ```

#### 2. 历史对比：Java 8 vs Java 16

##### 🔴 之前的解决方案 (Java 8)

为了定义一个简单的坐标点，我们需要手动编写 `final` 字段、构造器、Getter、`equals`、`hashCode` 和 `toString`，或者依赖 Lombok。

```Java
public final class OldPoint {
    private final int x;
    private final int y;

    public OldPoint(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // 繁琐的 Getter
    public int getX() { return x; }
    public int getY() { return y; }

    // 繁琐的 Object 方法重写
    @Override public boolean equals(Object o) { /*...*/ }
    @Override public int hashCode() { /*...*/ }
    @Override public String toString() { /*...*/ }
}
```

##### 🟢 新的解决方案 (Java 16+)

编译器自动处理所有样板代码，且支持更丰富的类特性。我们将**基础验证点**与**进阶元素**合并在下面的完整示例中。

```Java
import java.io.Serializable;

// 验证点 1：声明 (Declaration)
// 这一行代码，编译器自动生成了：
//1. private final 字段 (x, y) -> 确保不可变性
//2. 全参构造函数 (Canonical Constructor)
//3. 访问方法 public int x(), public int y()
//4. equals(), hashCode() (基于内容比较), toString()
// 验证点 4：实现接口 (Implements) -> Record 可以实现接口
public record Point(int x, int y) implements Comparable<Point>, Serializable {

    // 验证点 5：静态字段 (Static Fields) -> 允许定义常量
    public static final Point ORIGIN = new Point(0, 0);

    // 验证点 2：紧凑构造函数 (Compact Constructor)
    // 用于数据校验，省略了参数列表
    public Point {
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException("Coordinates must be non-negative");
        }
        // 注意：无需 this.x = x; 校验通过后自动赋值
    }

    // 验证点 6：重载构造函数 (Overloaded Constructors)
    // 必须通过 this() 调用主构造函数
    public Point(int v) {
        this(v, v);
    }

    // 验证点 7：自定义实例方法 (Instance Methods)
    // 既然是类，就可以写逻辑
    public double distanceFromOrigin() {
        return Math.hypot(x, y);
    }

    // 验证点 8：静态工厂方法 (Static Factory Methods)
    public static Point of(int x, int y) {
        return new Point(x, y);
    }

    // 接口方法实现
    @Override
    public int compareTo(Point other) {
        return Double.compare(this.distanceFromOrigin(), other.distanceFromOrigin());
    }
}
```

------



#### 3. 使用与验证 (Usage & Verification)

```Java
public class RecordDemo {
    public static void main(String[] args) {
        // 验证点 3：基础使用
        Point p1 = new Point(10, 20);

        // 访问器特性：方法名即变量名
        System.out.println(p1.x()); // ✅ p1.x()
        // System.out.println(p1.getX()); // ❌ 编译错误，没有 getX()

        // 自动生成的 toString()
        System.out.println(p1); // 输出: Point[x=10, y=20]

        // 验证点 9：模式匹配 (Java 21 Record Patterns)
        // 允许直接解构 Record 提取数据
        Object obj = new Point(3, 4);
        if (obj instanceof Point(int x, int y)) {
             System.out.println("X: " + x + ", Y: " + y);
        }
    }
}
```

#### 4. 底层机制解析 (Under the Hood)

| **特性**              | **说明**                                                     |
| --------------------- | ------------------------------------------------------------ |
| **实例变量修饰**      | 编译器自动添加 `private final`。从底层机制上确保记录类作为“不可变数据载体”的特性。 |
| **规范构造器**        | 默认生成初始化所有变量的构造器。如果手写了“紧凑构造函数”，编译器会将其逻辑注入到规范构造器中。 |
| **访问方法**          | 以 `变量名()` 形式提供（例如 `x()`）。保持语法简洁，明确其作为“数据直接访问”而非传统 JavaBean getter 的语义。 |
| **equals & hashCode** | 基于**所有**实例变量生成。确保在 `HashMap` / `HashSet` 中，只要数据内容一致（如 `x=1, y=1`），两个不同的对象也被视为相等（Value Object 语义）。 |
| **不可继承**          | Record 类默认是 `final` 的，且隐式继承自 `java.lang.Record`，因此它**不能继承其他类**，也不能被继承。 |

------



#### 5. 避坑指南 (Restrictions)

在使用 Record 时，需注意以下**不支持**的操作：

1. **不能 extends 类**：因为已经继承了 `java.lang.Record`（Java 是单继承）。
2. **不能定义实例字段**：除了构造函数里声明的 `(int x, int y)`，类体内**不能**定义额外的非静态成员变量（如 `private int z;` ❌）。
3. **不能声明为 abstract**：Record 的设计初衷就是具体的数据载体。



- **面试常见问题：**
  - **Q:** `record` 是什么？
  - **A:** `record` 是 Java 16 引入的一种新的类，专用于定义*不可变的* (Immutable) 数据载体。
  - **Q:** `record` 自动生成了哪些东西？
  - **A:** 自动生成 `private final` 字段、包含所有字段的“规范构造函数”、`public` 的访问器 (accessor, 如 `x()`)、以及 `equals()`, `hashCode()`, `toString()`。
  - **Q:** `record` 有什么限制？
  - **A:** 1. `record` 默认是 `final` 的，不能被继承 (但它可以实现接口)。 2. 它的字段隐式地是 `final` 的，因此 `record` 是不可变的。 3. 不能声明实例字段（只能声明在参数列表里）。

------



### 18. 密封类 (Sealed Classes) (JEP 409)

#### 1. 核心概念与背景

- **适用版本：** Java 15 (预览), **Java 17 (正式转正)**

- **核心目的：** 提供一种机制，让类能够**声明**：“这个类*只*允许这几个特定的类来继承我”。这让类层次结构更加可控，更适合领域建模。

- **基本语法：**

  ```Java
  public sealed class 父类 permits 子类A, 子类B { ... }
  ```



| 类类型             | 关键特性与用途                                               |
| ------------------ | ------------------------------------------------------------ |
| 普通类（class）    | 最基础的类形式，支持面向对象全特性，用于构建各类业务对象（如实体、工具类等） |
| 最终类（final）    | 不可被继承，保障类逻辑不被篡改，适用于工具类（如`String`）或固定逻辑类 |
| 密封类（sealed）   | 有限被继承，可指定子类范围，用于需控制继承关系的场景（如框架组件、领域模型） |
| 记录类（record）   | 不可变数据载体，编译器自动生成构造器、`equals`/`hashCode`/`toString`及字段访问方法，简化 DTO/VO 等数据类开发 |
| 枚举类（enum）     | 实例固定且有限，用于表示常量组（如星期、状态），支持方法增强功能性 |
| 抽象类（abstract） | 不能直接实例化，定义子类公共行为与抽象方法，用于多态场景（如框架基础组件、业务父类） |

> 拓展解读
>
> 这些类类型体现了 Java 在**面向对象设计、数据封装、逻辑约束**等维度的丰富能力：
>
> - 普通类是面向对象的基础载体，支撑业务逻辑的灵活构建；
> - 最终类、密封类从 “继承控制” 角度保障代码稳定性；
> - 记录类、枚举类聚焦 “数据封装与常量定义”，提升编码效率；
> - 抽象类则通过 “抽象约束” 实现多态，助力框架与业务的分层设计。
>
> 不同类类型的组合使用，让 Java 能适配从简单业务实体到复杂框架设计的各类场景。



#### 2. 解决了什么问题？

| **状态**       | **描述**                      | **问题**                                                     |
| -------------- | ----------------------------- | ------------------------------------------------------------ |
| **过于开放**   | 普通 `public` 类 (非 `final`) | 任何人都可以在任何地方继承它。这破坏了 API 的完整性，导致不可预知的子类行为。 |
| **过于封闭**   | `final` 类                    | 完全禁止继承。无法建立哪怕最基础的层级关系。                 |
| **之前的方案** | `default` (包私有) 构造器     | **非官方技巧**。强制所有子类必须在同一个包内，用包可见性来限制继承，代码组织笨拙。 |
| **新的方案**   | **`sealed` + `permits`**      | **精准控制**。介于完全开放和完全封闭之间，明确指定谁是“自己人”。 |

------



#### 3. 代码实战：构建受控层级

这是密封类最核心的规则：**一旦父类被密封，子类必须明确表态**。

```Java
// 验证点 1：父类的声明
// 语义："我是 Shape，我是一个封闭的圈子，只允许 Circle, Square, Rectangle 进入"
public abstract sealed class Shape 
    permits Circle, Square, Rectangle {
    // ... 通用逻辑
}

// ---------------------------------------------------------
// 验证点 2：子类的声明 (必须从以下三者选其一)
// ---------------------------------------------------------

// 选项 A：final (最常见)
// 语义："到此为止。" Circle 不能再被任何人继承。
public final class Circle extends Shape {
    public double radius() { return 1.0; }
}

// 选项 B：non-sealed (重新开放)
// 语义："我叛变了。" Square 重新开放继承，任何人都可以继承 Square。
// 这打破了密封性，但仅限于 Square 这个分支。
public non-sealed class Square extends Shape {
    public double side() { return 1.0; }
}

// 选项 C：sealed (继续密封)
// 语义："我会严格把关。" Rectangle 也是密封的，它只允许 TransparentRectangle 继承。
public sealed class Rectangle extends Shape 
    permits TransparentRectangle {
    public double width() { return 1.0; }
    public double height() { return 2.0; }
}

// Rectangle 的子类必须继续遵守规则
public final class TransparentRectangle extends Rectangle { }
```

------



#### 4. 杀手级特性：穷举性检查 (Exhaustiveness)

这是密封类最强大的实际应用场景。结合 `switch` 模式匹配，编译器变成了你的“逻辑检查员”。

```Java
// 验证点 3：与 Switch 表达式的完美结合
public static double getArea(Shape shape) {
    // 编译器知道 Shape 的全集只有：Circle, Square, Rectangle
    return switch (shape) {
        case Circle c    -> Math.PI * c.radius() * c.radius();
        case Square s    -> s.side() * s.side();
        case Rectangle r -> r.width() * r.height();
        
        // 重点：不需要 default 分支！
        // 编译器会帮你检查：
        // 1. 如果你覆盖了所有子类，编译通过。
        // 2. 如果未来有人加了一个 Triangle extends Shape，这里会立刻报错，提醒你处理新情况。
    };
}
```

------



#### 5. 总结

- **Sealed (密封)**：父类制定规则，只有白名单 (`permits`) 里的类能继承。
- **Final (终结)**：子类彻底关闭继承。
- **Non-sealed (解封)**：子类重新开放继承。
- **Exhaustiveness (穷举)**：Switch 表达式不再需要 `default`，编译器确保你处理了所有可能的类型。



- **面试常见问题：**
  - **Q:** 什么是密封类 (Sealed Class)？
  - **A:** 它允许一个类或接口*精确地控制*哪些其他类可以继承或实现它。
  - **Q:** `sealed`, `permits`, `non-sealed` 关键字各是做什么的？
  - **A:** 1. `sealed` 用在父类上，声明这是一个密封类。 2. `permits` 用在父类上，列出*允许*继承的子类。 3. 子类必须使用 `final`, `sealed` 或 `non-sealed` 来声明自己的继承状态。`non-sealed` 表示“重新开放继承”。
  - **Q:** 密封类和 Switch 表达式一起使用有什么好处？
  - **A:** 编译器可以进行*详尽的类型检查*。在 `switch` 中处理密封类的所有 `permits` 子类型后，就不再需要 `default` 分支，编译器能保证所有情况都被覆盖。

------



### 19. 低延迟垃圾回收器：Shenandoah



Shenandoah 是 Red Hat 主导开发（2018 年纳入 OpenJDK 版本）的高性能 GC，为 Java 在大内存场景下的低延迟需求提供了重要的技术选项！其核心目标是：在堆内存非常大的情况下（几百 GB），仍然保持低停顿时间（通常低于 10ms）。它与 G1 和 ZGC 属于同一类别的低延迟 GC，但采用了不同的技术路线。

#### Shenandoah vs 其他低延迟 GC 对比表

| 特性维度     | G1 GC                            | Shenandoah GC                | ZGC                          |
| ------------ | -------------------------------- | ---------------------------- | ---------------------------- |
| 主导开发方   | Oracle                           | Red Hat                      | Oracle                       |
| JDK 引入版本 | JDK 9（实验）JDK 8（默认的 GCC） | OpenJDK14（标准）            | JDK 11（实验）JDK 15（标准） |
| 核心技术     | 分区算法 Remembered Sets         | 转发指针 Brooks Pointer      | 染色指针 Colored Pointers    |
| 内存开销     | 高 (~10-20%) RSets、Bitmaps      | 中等 (~5-10%) Brooks Pointer | 低 (~1-2.5%) 内存映射        |
| 并发阶段     | 并发标记                         | 并发标记 并发压缩            | 完全并发 标记、压缩、重定位  |
| 压缩方式     | 并行压缩 (Evacuation Pauses)     | 并发压缩                     | 并发压缩                     |
| 停顿时间目标 | 200ms                            | < 10ms                       | < 1ms（亚毫秒级）            |
| 最大堆支持   | 数十 GB                          | 数 TB                        | 数 TB                        |
| CPU 开销     | 低                               | 高                           | 中等                         |
| 分代支持     | ✅ 分代式 (年轻代 / 老年代)       | ❌ 不分代 (全堆回收)          | ✅ 可选分代（JDK 21+ 分代式） |
| 适用堆大小   | 6GB - 数十 GB                    | 数十 GB - 数 TB              | 数百 GB - 数 TB              |
| 成熟度       | 非常成熟 广泛生产验证            | 成熟 生产就绪                | 成熟 生产就绪                |

#### **G1 的分区算法**

- G1 不再坚持传统的物理上连续的年轻代和老年代划分。将整个 Java 堆划分为多个大小相等（例如 1M,2M,4M）的 **Region**。每个 Region 在逻辑上被标记为属于某一类型，如 Eden、Survivor、Old 或 Humongous（用于存放大对象）
- G1 分析各个 Region，计算出每个 Region 的 “**回收价值**” 和 “**回收成本**”。一个 Region 中垃圾对象的多少。垃圾越多，回收后释放的空间就越多，价值就越高。复制该 Region 中存活对象所需的时间（存活对象越少，成本越低）。**每次回收的不是 “最老” 的数据，而是 “垃圾最多” 的 Region，从而在有限时间内释放出尽可能多的内存**。
- G1 会根据用户设定的**最大停顿时间目标**，从所有 Region 中**筛选出一批 “回收价值最高” 的 Region** 组成一个回收集。然后，**G1 会暂停应用线程**，将回收集（CSet）中所有 Region 的**存活对象复制到新的空 Region 中**（整个过程是压缩 / 整理的），然后清空整个回收集，将其归还给空闲列表。通过控制回收集的大小，来努力满足用户设定的停顿时间目标。

![image-20251119000741310](C:\Users\gouwe\Desktop\images\新特性\image-20251119000741310.png)



#### **Shenandoah GC 转发指针**

- **在对象头之前增加一个额外的引用字段**，这个字段就是 Brooks Pointer。
- 在开始复制一个对象时，Shenandoah 并不立即删除原对象。它首先在新目标位置创建该对象的副本。
- 然后，原子性地将原对象 A 的 Brooks Pointer 字段的值，从 null 更新为指向新副本 A' 的地址。
- 此后，任何线程（无论是 GC 线程还是应用线程）在访问这个对象时，都必须先通过这个转发指针。
- 等到一个安全点，Shenandoah 会执行一个**并发引用更新**阶段，然后删除旧对象 A。

![image-20251119001019485](C:\Users\gouwe\Desktop\images\新特性\image-20251119001019485.png)

- **适用版本：** Java 12 (实验性引入, OpenJDK)
- **解决了什么问题：** 与 ZGC 类似，G1 的停顿时间在某些对延迟*极其敏感*（例如金融、游戏）的*大堆内存*应用中，仍然可能过长（几十到几百毫秒）。
- **之前的解决方案：** G1 (追求吞吐量和延迟的平衡), CMS (已废弃)。
- **新的解决方案 (Shenandoah)：**
  - **目标：** 一款并发的、低停顿的 GC，其停顿时间*不*随堆大小的增长而增长。
  - **核心技术：** 与 ZGC 目标一致，但实现技术不同。Shenandoah 侧重于*并发*处理（即与应用线程同时运行）GC 的绝大部分工作，包括*并发的标记*和*并发的压缩整理*。
  - **并发整理：** 它使用一种称为 "Brooks Pointers" 的转发指针技术，允许它在应用线程还在运行时，就移动（整理）对象，从而极大地减少了 STW 时间。
  - **对比 ZGC:** ZGC 和 Shenandoah 是两款朝着相同目标（超低延迟）努力的 GC。ZGC 使用“有色指针”，Shenandoah 使用“Brooks 指针”。在 Java 17+ 的时代，两者都是非常优秀的选择。
  - **注意：** Shenandoah 主要由 Red Hat 贡献，并集成在 OpenJDK 的主流版本中（但在 Oracle 官方的 JDK 构建中*可能*不包含）。ZGC 是 Oracle 主导开发的。
- **面试常见问题：**
  - **Q:** 什么是 Shenandoah GC？
  - **A:** 它是一款与 ZGC 目标类似的超低延迟垃圾回收器。它通过并发执行绝大多数 GC 任务（包括标记和整理），将 STW 停顿时间控制在几毫秒级别。
  - **Q:** 它和 ZGC 有什么区别？
  - **A:** 它们是实现同一目标（超低延迟）的两种不同技术。ZGC 使用有色指针，Shenandoah 使用 Brooks 指针来实现并发整理。两者都是 G1 的下一代演进方向。

#### **ZGC 的染色指针**

- 在 64 位的系统中，指针地址有 64 位，但并非所有位都用于寻址。比如，在目前的主流硬件上，实际只用了 48 位进行寻址，高 16 位没有使用。ZGC 巧妙地利用了这些**未使用的指针位**来存储与垃圾收集相关的元数据。
- ZGC 主要使用了 48-51 这 4 个比特位来标记指针的状态，这就是 “染色” 的含义。这些状态包括：
  - Finalizable：对象是否只能通过 finalizer 方法访问？
  - Remapped：对象是否已被重映射到新的地址？（即是否在 ZGC 的 “转发表” 中）
  - Marked1 / Marked0：用于并发标记阶段，标记对象是否为存活对象。使用两个交替的标记位来处理连续的标记周期。
- 周期 1：
  - 当应用线程从堆中加载一个引用时（例如 `Object a = obj.field;`），ZGC 的屏障会被触发。这个屏障会检查加载出来的指针的 “颜色”。
    - 情况 A：如果当前是标记阶段，屏障发现指针的 M0 位是 0，说明这个对象还没被标记为存活。屏障会将其标记为存活（实质上就是将其 M0 位改为 1）。
    - 情况 B：如果当前是标记阶段，屏障发现指针的 M0 位是 1，屏障会去查一个 “转发表”。如果 “转发表” 中没有该对象的新地址，说明该对象存活且未被转移；如果找到对象的新地址，并返回一个 Remapped 位为 1 的新指针以更新引用。
  - GC 线程进行速度极快的 GC Roots 扫描，标记查看存活对象并更新引用，并清理全局转发表。
- 周期 2：与周期 1 相同，只是本次标记存活对象的标记为 M1。

![image-20251119004451383](C:\Users\gouwe\Desktop\images\新特性\image-20251119004451383.png)



![image-20251119004438968](C:\Users\gouwe\Desktop\images\新特性\image-20251119004438968.png)





------

## 18-21新特性

| 版本   | 主要新特性           | 引入状态    | 后续状态与说明                                               |
| ------ | -------------------- | ----------- | ------------------------------------------------------------ |
| JDK 18 | UTF-8 作为默认字符集 | 标准特性    | 依赖于默认字符集的 API 在所有实现、操作系统、区域设置和配置中保持一致 |
|        | 简单的 Web 服务器    | 标准特性    | 提供命令行工具启动最小网络服务器，用于原型设计、临时编码和测试 |
|        | JavaDoc 代码片段     | 标准特性    | 简化 API 文档中嵌入示例源代码的难度（@snippet）              |
|        | Switch 模式匹配      | 第 2 次预览 | 在 JDK 17 预览基础上增强                                     |
|        | 外部函数和内存 API   | 第 2 孵化器 | 使 Java 程序能够调用本机库并处理本机数据                     |
|        | Vector API           | 第 3 孵化器 | 引入 API 表达向量计算，在运行时编译为最佳向量指令            |
| JDK 19 | 虚拟线程             | 预览        | 旨在大幅减少编写、维护和观察高吞吐量并发应用程序的工作量     |
|        | 记录模式             | 预览        | 使用记录模式增强 Java 编程语言以解构记录值                   |
|        | Switch 模式匹配      | 第 3 次预览 | 针对前两轮预览反馈进行了增强                                 |
|        | 外部函数和内存 API   | 预览        | 由孵化器阶段进入预览阶段                                     |
|        | 结构化并发           | 孵化器      | 通过引入新的库来简化多线程编程，将多个任务视为单个工作单元   |
|        | Vector API           | 第 4 孵化器 | 根据前三轮孵化的反馈进行了改进                               |
| JDK 20 | 虚拟线程             | 第 2 次预览 | 在 JDK 19 预览版的基础上，进行了一些 API 更改和其他改进      |
|        | 作用域值             | 孵化器      | 允许在线程内和线程间共享不可变数据，并且优先于线程局部容量   |
|        | 外部函数和内存 API   | 第 2 次预览 | 进一步完善 API，增强稳定性                                   |
|        | Vector API           | 第 5 孵化器 | 持续优化向量计算的性能与兼容性                               |
| JDK 21 | 虚拟线程             | 标准特性    | 从预览阶段晋升为标准特性，为高吞吐量并发应用提供轻量级线程支持，大幅降低并发编程复杂度 |
|        | 记录模式             | 标准特性    | 从预览阶段晋升为标准特性，增强 Java 对记录值的解构能力，简化数据处理逻辑 |
|        | Switch 模式匹配      | 标准特性    | 从第三次预览阶段晋升为标准特性，完善模式匹配语法，提升代码可读性与简洁性 |
|        | 字符串模板           | 预览特性    | 简化字符串拼接与格式化，支持嵌入式表达式与模板化字符串构建   |
|        | 密钥封装机制（KEM）  | 标准特性    | 标准化加密 API，支持现代密钥封装算法，增强 Java 加密应用的安全性与兼容性 |
|        | 分代式 ZGC           | 标准特性    | ZGC 引入分代支持，区分年轻代与老年代，提升大内存场景下的垃圾回收性能 |
|        | 作用域值             | 预览特性    | 从孵化器阶段进入预览阶段，优化线程间不可变数据共享机制，提升并发编程的安全性 |

### 20. 记录类对象解构 (Record Deconstruction) (JEP 405/440)



- **适用版本：** Java 16 (用于 `instanceof`), Java 21 (正式，JEP 440)

- **解决了什么问题：** `instanceof` 模式匹配（Java 16）和 `switch` 模式匹配（Java 21）虽然可以识别出一个对象是 `record`，但我们通常还想立刻获取它*内部*的组件（字段）。

- **之前的解决方案 (Java 16)：**

  ```Java
  record Point(int x, int y) {}
  
  void printSum(Object obj) {
      if (obj instanceof Point p) {
          // 虽然有了 p，但还必须手动调用 getter
          int x = p.x();
          int y = p.y();
          System.out.println(x + y);
      }
  }
  ```
  
- **新的解决方案 (Java 21)：** `record` 模式匹配（或称“解构”）。在类型检查的同时，直接将 `record` 的组件解构到新的局部变量中。

- **代码对比：**

  ```Java
  record Point(int x, int) {}
  
  // 之后 (Java 21)
  void printSum(Object obj) {
  
      // 验证点：
      // 当 obj 是一个 Point 时，
      // 不仅将其转换为 Point 类型（隐式的 p），
      // 还将其内部的 x() 和 y() 组件提取到
      // 新的局部变量 int x 和 int y 中。
      if (obj instanceof Point(int x, int y)) {
  
          // x 和 y 在这里直接可用
          System.out.println(x + y);
      }
  }
  ```
  
- **面试常见问题：**

  - **Q:** 什么是 `record` 解构？
  - **A:** 它是一种模式匹配的扩展。当 `instanceof` 或 `switch` 确认一个对象是 `record` 类型时，它允许你同时将其内部的组件（字段）“解开”并直接赋给新的局部变量。例如 `if (obj instanceof Point(int x, int y))`。



### 21. Switch 模式匹配 (JEP 441)

JDK 21 中成为标准特性的 Switch 模式匹配，极大增强了`switch`的表达能力和安全性，核心特性如下：

- **类型模式匹配**：`switch`可直接对变量类型进行匹配并自动类型转换，无需手写`if-else-if`链和显式类型转换。与传统`if-else-if`链（时间复杂度 O (n)）相比，其底层多采用表驱动机制，理论时间复杂度 O (1)，在分支较多时性能更优。
- **守卫模式（Guarded Patterns）**：通过`when`关键字在`case`中增加额外条件判断，使匹配逻辑更精确，提升分支判断的灵活性。
- **处理 null 值**：传统`switch`遇到`null`会抛出`NullPointerException`，现在可直接用`case null`显式处理`null`值，让代码健壮性更强。
- **密封类场景优化**：针对密封类，编译器能智能判断`switch`是否穷尽所有类型，减少不必要的`default`分支，提升代码的严谨性。
- **Record 模式匹配**：Record 模式（允许解构 Record 对象）也在 JDK 21 中成为标准特性，支持在`instanceof`和`switch`中直接解构 Record 对象，简化数据类的处理逻辑。



- **适用版本：** Java 17 (预览), Java 21 (正式)

- **解决了什么问题：**

  1. 传统的 `switch` 只能对原始类型 (int, char), `String`, `Enum` 进行匹配。
  2. 如果想根据一个*对象*的*类型*来执行不同逻辑，只能写一长串的 `if-else-if (obj instanceof ...)`。

- **之前的解决方案 (Java 8/11)：** `if-else-if` 链。

  ```Java
  // 假设有 Shape 密封类 (Circle, Square)
  static double getArea(Shape shape) {
      if (shape instanceof Circle c) {
          return Math.PI * c.radius() * c.radius();
      } else if (shape instanceof Square s) {
          return s.side() * s.side();
      } else {
          return 0;
      }
  }
  ```
  
- **新的解决方案 (Java 21)：** `switch` 语句（和表达式）现在可以直接用于*类型*的模式匹配。

- **代码对比：**

  ```Java
  // 之后 (Java 21)
  
  record Point(int x, int y) {}
  
  static void checkObject(Object obj) {
      // 验证点 1：按类型匹配
      switch (obj) {
          // case 后面现在可以是类型 + 变量
          case String s -> System.out.println("这是一个字符串: " + s);
          case Integer i -> System.out.println("这是一个整数: " + i);
  
          // 验证点 2：与 Record 解构结合 (JEP 440)
          case Point(int x, int y) -> System.out.println("这是一个点，x=" + x + ", y=" + y);
  
          // 验证点 3：case null
          // 以前的 switch 遇到 null 会直接抛 NPE
          // 现在的 switch 可以显式处理 null
          case null -> System.out.println("这是一个 null");
  
          case default -> System.out.println("其他类型");
      }
  }
  
  // 验证点 4：带 'when' 子句的守卫模式 (Guarded Patterns)
  static void checkString(Object obj) {
      switch (obj) {
          // 只有当 obj 是 String 且 长度>5 时，才匹配
          case String s when s.length() > 5 -> System.out.println("一个长字符串");
  
          // 否则，如果 obj 是 String (不管长度)，匹配这个
          case String s -> System.out.println("一个短字符串");
  
          default -> { /* ... */ }
      }
  }
  ```
  
- **面试常见问题：**

  - **Q:** Java 21 中 Switch 的最大增强是什么？
  - **A:** **Switch 模式匹配**。`switch` 不再局限于基本类型和字符串，它可以对*对象*的*类型*进行匹配，并结合 `instanceof` 模式匹配（如 `case String s`）和 `record` 解构（如 `case Point(x, y)`）。
  - **Q:** `case null` 是做什么用的？
  - **A:** 传统的 `switch` 传入 `null` 会抛 `NullPointerException`。Java 21 的 `switch` 允许你安全地处理 `case null` 分支，而不会抛 NPE。
  - **Q:** 什么是守卫模式 (Guarded Patterns)？
  - **A:** 是指在 `case` 后面增加一个 `when` 子句（如 `case String s when s.length() > 5`），为模式匹配提供了额外的布尔条件。

------



### 22. 序列集合 (Sequenced Collections) (JEP 431)

JEP 431 是 Java 21 中引入的重要特性，旨在为**有序集合**提供**统一的 API 规范和增强功能**，解决了 Java 此前在有序集合操作中 “API 分散、行为不一致” 的痛点，大幅提升了有序数据处理的便捷性与一致性。

为 Java 中所有**元素有明确顺序**的集合（如 `List`、`Deque`、`LinkedHashSet`、`LinkedHashMap` 等）定义统一的接口和操作方法，让开发者能以一致的方式操作 “有序集合”，降低学习成本并增强功能扩展性。



**核心接口和新增常用方法**

| 接口 / 类             | 核心特性                                                     | 新增常用方法 (含部分 JDK 已有)                               |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `SequencedCollection` | 定义了元素有明确顺序的集合。                                 | addFirst, addLast, getFirst, getLast, removeFirst, removeLast, reversed |
| `SequencedSet`        | 一种特殊的 SequencedCollection，不允许重复元素，并覆盖 reversed 方法。 | 继承自 SequencedCollection 的所有方法。                      |
| `SequencedMap`        | 定义了键值对有明确顺序的映射。                               | putFirst, putLast, firstEntry, lastEntry, pollFirstEntry, pollLastEntry, reversed |

**序列集合的应用场景**

序列集合适用于许多需要处理有序数据的场景，例如：

- 事件日志记录：按照事件发生的顺序将事件添加到序列集合中，便于后续按时间顺序分析和查询。
- 任务调度：将任务按照执行顺序添加到序列集合中，并依序执行。
- 数据处理：在处理有序数据集时，使用序列集合来保持数据的顺序。

**序列集合的优势**

总结来说，序列集合带来了以下几个主要优势：

- 一致性：为所有有序集合提供了统一的操作 API。
- 便捷性：轻松访问和操作集合的第一个和最后一个元素。
- 功能增强：通过`reversed()`等方法提供了新的操作维度。

![image-20251119013907585](C:\Users\gouwe\Desktop\images\新特性\image-20251119013907585.png)

- **代码对比：**

  ```Java
  // 假设我们有一个 List
  List<String> list = new ArrayList<>();
  list.add("B");
  list.addFirst("A"); // (Java 21 新增)
  list.addLast("C");  // (Java 21 新增, 等价于 add)
  
  // 之前 (Java 8/11)
  String first = list.get(0);
  String last = list.get(list.size() - 1);
  
  // 之后 (Java 21)
  // 验证点 1：统一的获取 API
  String first = list.getFirst(); // "A"
  String last = list.getLast();   // "C"
  
  
  // 假设我们有一个 LinkedHashSet (它也有序!)
  SequencedSet<String> set = new LinkedHashSet<>();
  set.add("One");
  set.add("Two");
  set.add("Three");
  
  // 之前 (Java 8/11)：获取最后一个元素非常困难
  
  // 之后 (Java 21)
  String setFirst = set.getFirst(); // "One"
  String setLast = set.getLast();   // "Three"
  
  // 验证点 2：反转视图 (reversed())
  // 这是一个轻量级的“视图”，不是拷贝
  SequencedCollection<String> reversedView = list.reversed();
  System.out.println(reversedView); // [C, B, A]
  ```

- **面试常见问题：**

  - **Q:** 什么是序列集合 (Sequenced Collections)？
  - **A:** 它是 Java 21 引入的一系列新接口 (`SequencedCollection`, `SequencedSet`, `SequencedMap`)，它们统一了*所有*具有确定顺序的集合（如 `List`, `LinkedHashSet`, `SortedMap`）的 API。
  - **Q:** 它提供了哪些关键方法？
  - **A:** 提供了 `getFirst()`, `getLast()`, `addFirst()`, `addLast()`, `removeFirst()`, `removeLast()` 以及一个 `reversed()` 视图。这使得从任何有序集合的两端操作都变得统一和简单。

------



### 23. 虚拟线程 (Virtual Threads) (Project Loom) (JEP 444)



- **适用版本：** Java 19 (预览), Java 21 (正式)

- **解决了什么问题：** 这是 Java 近 10 年来最重要的特性之一。它解决了传统“一个请求一个线程”(Thread-per-Request) 模式下的*并发性能瓶颈*。

  - **问题：** Java 传统的 `Thread`（现在称为**平台线程**）是昂贵的。它1对1直接映射到操作系统的内核线程。
  - **成本：** 1. 创建成本高。 2. 内存占用大 (通常 1MB+ 的栈空间)。 3. 上下文切换昂贵。
  - **瓶颈：** 一个普通的服务器只能同时处理几千个平台线程，无法应对 C10K/C100K (十万/百万并发) 的场景。
  - **I/O 阻塞：** 在传统的阻塞式 I/O 中（如 `Socket.read()`, `JDBC.query()`），平台线程会*挂起*，白白占用资源，等待 I/O 完成。

- **之前的解决方案：**

  1. **异步编程 (CompletableFuture)：** 基于回调，代码难以编写、阅读和调试（“回调地狱”）。
  2. **响应式编程 (Reactor, RxJava)：** 学习曲线陡峭，对整个代码库具有传染性。

- **新的解决方案 (Java 21)：** 虚拟线程 (Virtual Threads)。

  - **轻量级：** 虚拟线程是*极度*轻量级的。它们由 JVM 自己管理，不再 1:1 映射到 OS 线程。
  - **海量：** 你可以轻松创建*数百万*个虚拟线程。
  - **不阻塞 (Park)：** 当虚拟线程执行阻塞 I/O 操作时，它不会阻塞底层的 OS 线程（平台线程）。它会*释放* (unmount) OS 线程，并将自己的状态保存。当 I/O 完成后，JVM 会将其重新调度 (mount) 到某个可用的 OS 线程上继续执行。
  - **相同的 API：** 它仍然是 `java.lang.Thread`，你几乎不需要修改你的*同步*、*阻塞式*代码。

  | 方面         | 传统平台线程                      | 虚拟线程                                         |
  | ------------ | --------------------------------- | ------------------------------------------------ |
  | 本质         | 操作系统线程的 1:1 包装           | JVM 管理的轻量级线程，与 OS 线程 N:M 映射        |
  | 资源开销     | 高（~1MB / 线程，创建销毁成本高） | 低（内存开销小，创建销毁快）                     |
  | 数量级       | 通常数千个                        | 可达数百万个                                     |
  | 适用场景     | CPU 密集型任务                    | I/O 密集型任务（如 Web 服务器、数据库查询）      |
  | 阻塞操作影响 | 阻塞操作系统线程，浪费资源        | I/O 阻塞时自动挂起，释放载体线程运行其他虚拟线程 |

  

**核心原理**

虚拟线程通过 “载体线程” 实现其魔力：

- **挂载与卸载**：虚拟线程在执行计算任务时，会挂载到一个平台线程（载体线程）上。当遇到 I/O 等阻塞操作时，虚拟线程会从载体线程上卸载并进入等待状态，载体线程随即被释放，可以去执行其他就绪的虚拟线程。
- **状态保存与恢复**：卸载时，虚拟线程的栈帧等状态会保存在 JVM 的堆内存中。当 I/O 操作完成，虚拟线程会被重新挂载到载体线程上恢复执行。
- **JVM 调度**：虚拟线程由 JVM 调度，其调度器比操作系统内核的调度器更轻量，能高效管理海量虚拟线程的上下文切换。



**重要注意事项**

虚拟线程虽好，但并非万能，使用时需要注意以下几点：

- **CPU 密集型任务**：对于计算密集型任务，虚拟线程的优势不明显。此时，虚拟线程会持续占用载体线程，其性能表现与传统平台线程相似，甚至可能因额外的调度层而略有下降。因此，虚拟线程主要适用于 I/O 密集型工作负载。
- **线程局部变量**：虚拟线程支持 `ThreadLocal`，但由于可以创建海量虚拟线程，需谨慎使用，避免内存压力。
- **“打孔” 现象**：当虚拟线程在执行 `synchronized` 方法或代码块时，或者在执行本地方法时，它会被 “钉” 在当前的载体线程上而无法卸载。这会导致载体线程被阻塞，影响可扩展性。建议在虚拟线程中，使用 `java.util.concurrent.locks.ReentrantLock` 等显式锁来替代 `synchronized`，以避免钉扎现象。



- **代码对比：**

  ```Java
  // 之前 (Java 8/11)：使用平台线程池
  ExecutorService executor = Executors.newFixedThreadPool(200);
  
  // 提交 10,000 个任务
  // 如果线程池只有 200，那么 9,800 个任务在排队
  for (int i = 0; i < 10_000; i++) {
      executor.submit(() -> {
          // 假设这是一个阻塞操作 (如 API 调用)
          Thread.sleep(Duration.ofSeconds(1)); 
          return "Task finished";
      });
  }
  
  // ---
  
  // 之后 (Java 21)：使用虚拟线程
  
  // 验证点 1：为每个任务创建一个新的虚拟线程 (推荐方式)
  // 这是一个开销极低的 ExecutorService
  try (ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor()) {
  
      // 提交 10,000 个任务
      // JVM 会立即创建 10,000 个虚拟线程
      // 它们并发运行，只使用少量平台线程 (默认等于 CPU 核心数)
      for (int i = 0; i < 10_000; i++) {
          virtualExecutor.submit(() -> {
              // 验证点 2：
              // 当这个 sleep (或 JDBC, HTTP 调用) 阻塞时，
              // 虚拟线程会释放它占用的平台线程 (OS 线程)，
              // 允许那个平台线程去执行别的任务。
              // 这 10,000 个任务会*几乎同时*开始。
              Thread.sleep(Duration.ofSeconds(1));
              return "Task finished";
          });
      }
  } // try-with-resources 会自动关闭
  
  // 验证点 3：手动启动虚拟线程 (了解即可)
  Thread.startVirtualThread(() -> {
      System.out.println("我在虚拟线程上运行！");
  });
  ```

- **源码解读 (核心概念)：**

  - 虚拟线程运行在“载体线程”(Carrier Thread) 上，载体线程就是平台线程 (Platform Thread)。
  - JVM 维护一个（或多个）`ForkJoinPool` 作为虚拟线程的默认调度器。
  - 当虚拟线程遇到阻塞 I/O (park) 时，它会从载体线程上“卸载”(unmount)，让载体线程去执行其他虚拟线程。

- **面试常见问题：**

  - **Q:** 什么是虚拟线程？它解决了什么问题？
  - **A:** 虚拟线程是 JVM 管理的超轻量级线程，它解决了传统平台线程（映射到 OS 线程）数量有限且开销大的问题。它允许我们用同步、阻塞的编码风格，实现异步、非阻塞的高并发性能。
  - **Q:** 虚拟线程和平台线程有什么区别？
  - **A:** 平台线程是昂贵的，直接映射到 OS 线程，数量受限（几千个）。虚拟线程是廉价的，由 JVM 管理，可以创建数百万个。
  - **Q:** 虚拟线程是如何处理 I/O 阻塞的？
  - **A:** 当虚拟线程遇到阻塞 I/O（如网络、JDBC），它会“休眠”(park) 并自动从其载体（平台线程）上卸载，释放平台线程去执行其他任务。I/O 结束后，JVM 会重新调度该虚拟线程到任意一个可用的平台线程上继续执行。
  - **Q:** 切换到虚拟线程，我的代码需要改动吗？
  - **A:** 绝大多数的*同步阻塞式*代码（如 Spring Boot Controller 里的业务逻辑）不需要改动。主要改动是创建线程的方式，从 `newFixedThreadPool` 改为 `Executors.newVirtualThreadPerTaskExecutor()`。
  - **Q:** 虚拟线程会取代 `CompletableFuture` 吗？
  - **A:** 在“并发执行多个 I/O 任务”的场景下，虚拟线程（通过结构化并发）是更简单、更符合人脑思维的替代方案。`CompletableFuture` 在处理复杂的“事件驱动”和“回调”逻辑时仍有用，但对于主流的 I/O 密集型应用，虚拟线程是未来的方向。

------



### 24. KEM 密钥封装机制 API (JEP 452)



Java 21 引入的**密钥封装机制（KEM）API**是一项重要的安全增强，它提供了一种标准化的方式来使用**非对称（公钥）**加密技术安全地**传递对称**密钥。

> 为什么需要混合加密系统？

1. 对称加密

- **原理**：加密和解密使用同一把密钥。
- **例子**：DES、3DES（DES/3DES 已过时）、ChaCha20、AES（AES 是目前世界上最流行、最受信任的对称加密算法）。
- **优点**：
  - 速度快：计算开销小，非常适合加密大量数据。
- **缺点**：
  - 密钥分发问题：如何安全地把密钥交给对方？如果密钥在传输中被截获，整个通信就会被破解。这就像你把秘密锁在盒子里，却不知道如何把钥匙安全地寄给对方。

2. 非对称加密

- **原理**：使用一对密钥：公钥和私钥。公钥可以公开，用于加密；私钥必须保密，用于解密。用公钥加密的内容，只有对应的私钥才能解密。
- **例子**：RSA、ECC、ElGamal、X25519（X25519 是当今毫无疑问的最佳选择，因为它快速、安全且轻量）。
- **优点**：
  - 解决了密钥分发问题：你可以把公钥像电话号码一样公开给任何人，他们都可以用这个公钥加密信息，但只有你用自己的私钥才能解密。
- **缺点**：
  - 速度慢：计算非常复杂，比对称加密慢几个数量级，不适合加密大量数据。
  - 对明文有要求：某些非对称加密算法（如 RSA）不能加密超过其密钥长度的数据。

3. DHKEM

- **全称**：迪菲 - 赫尔曼密钥封装机制
- **类型**：非对称密码学 / 密钥协商
- **本质**：它不是加密算法，而是一个框架，将迪菲 - 赫尔曼密钥交换与密钥封装的思想结合，用于安全地传输一个对称密钥。

+ **工作流程（简化）**

  + > 1. 准备：接收方有一个长期密钥对，公开公钥。
    > 2. “封装（发送方）”：
    >    - 生成临时密钥对。
    >    - 用自己的临时私钥和接收方的长期公钥进行 DH 计算，得出共享秘密。
    >    - 用共享秘密派生出对称密钥。
    >    - 将自己的临时公钥作为 “封装”，和派生出的对称密钥一起保存。
    >    - 立即丢弃临时私钥。
    > 3. 解封（接收方）：
    >    - 收到 “封装”（即发送方的临时公钥）。
    >    - 用自己的长期私钥和收到的临时公钥进行相同的 DH 计算，得到相同的共享秘密。
    >    - 派生出相同的对称密钥。

+ **与经典 DH 的区别**

  - 经典 DH：双方共同商定一个共享秘密。

  - DHKEM：一方主动生成一个密钥，并 “封装” 起来发送给另一方。这更符合混合加密系统中 “发送方加密数据给接收方” 的场景。

+ **优势**

  - 前向安全：如果使用临时密钥，即便攻击者记录了通信并后来获取了接收方的长期私钥，也无法解密过去的会话。

  - 形式化安全证明：KEM 框架更容易进行严格的安全证明。
  - 理解算法特性：不同的 KEM 算法在性能、安全强度和抗量子攻击能力上有所不同，应根据具体需求选择。



![image-20251119015902371](C:\Users\gouwe\Desktop\images\新特性\image-20251119015902371.png)

---

- **适用版本：** Java 21 (预览)

- **解决了什么问题：** 这是一个高度专业化的*密码学*特性。

  - **背景：** 在传统的*混合加密*（Hybrid Encryption）中，如 TLS/HTTPS，我们通常这样做：
    1. **发送方 (Client)：** 生成一个对称密钥（如 AES）。
    2. **发送方：** 用接收方的*公钥*（如 RSA 公钥）加密这个 AES 密钥。
    3. **发送方：** 将加密后的 AES 密钥 和 AES 加密的数据 一起发给接收方。
  - **问题：** 上述第二步中的 RSA 加密（称为 KEM - 密钥封装机制），在 Java API (`javax.crypto`) 中没有一个标准化的、高级别的抽象。

- **之前的解决方案：** 开发者需要手动组合低级别的加密原语（如 RSA, ECIES）来实现 KEM，这很复杂且容易出错。

- **新的解决方案 (Java 21)：** 提供了一个高级别的 KEM API。

  - 引入 `KEM` 类，允许安全地封装（加密）对称密钥，以便传输。
  - 主要用于高级密码学应用，尤其是应对未来*后量子密码学* (PQC) 的标准化。

- **代码示例 (概念性)：**

  ```Java
  import javax.crypto.Cipher;
  import javax.crypto.KeyGenerator;
  import javax.crypto.SecretKey;
  import javax.crypto.spec.GCMParameterSpec;
  import java.nio.charset.StandardCharsets;
  import java.security.*;
  import java.security.spec.NamedParameterSpec;
  import java.util.Base64;
  
  public class KEMExample {
      public static void main(String[] args) throws Exception {
          // 1. 接收方：生成长期DHKEM密钥对（公钥公开，私钥保密）
          KeyPairGenerator receiverKpg = KeyPairGenerator.getInstance("X25519"); // 基于Curve25519的DH密钥对
          KeyPair receiverKeyPair = receiverKpg.generateKeyPair();
          PublicKey receiverPublicKey = receiverKeyPair.getPublic();
          PrivateKey receiverPrivateKey = receiverKeyPair.getPrivate();
  
  
          // 2. 发送方：使用接收方公钥封装对称密钥
          // 2.1 初始化KEM封装器（算法为DHKEM，参数指定曲线和密钥派生函数）
          KeyEncapsulation senderKem = KeyEncapsulation.getInstance(
              new NamedParameterSpec("DHKEM(X25519, HKDF-SHA256)")
          );
          senderKem.init(receiverPublicKey); // 传入接收方公钥
  
          // 2.2 生成临时密钥对并封装：返回封装体（给接收方）和派生的对称密钥（发送方自用）
          byte[] encapsulation = new byte[senderKem.getEncapsulationLength()];
          SecretKey symmetricKey = senderKem.encapsulate(encapsulation); // 核心：封装操作
          System.out.println("发送方生成的封装体：" + Base64.getEncoder().encodeToString(encapsulation));
  
  
          // 3. 接收方：使用私钥解封，获取对称密钥
          // 3.1 初始化解封器
          KeyEncapsulation receiverKem = KeyEncapsulation.getInstance(
              new NamedParameterSpec("DHKEM(X25519, HKDF-SHA256)")
          );
          receiverKem.init(receiverPrivateKey); // 传入接收方私钥
  
          // 3.2 解封：从封装体中恢复对称密钥
          SecretKey receivedSymmetricKey = receiverKem.decapsulate(encapsulation); // 核心：解封操作
  
  
          // 4. 验证：双方对称密钥是否一致（实际场景无需验证，算法保证一致性）
          System.out.println("发送方对称密钥：" + Base64.getEncoder().encodeToString(symmetricKey.getEncoded()));
          System.out.println("接收方对称密钥：" + Base64.getEncoder().encodeToString(receivedSymmetricKey.getEncoded()));
          System.out.println("密钥一致：" + symmetricKey.equals(receivedSymmetricKey));
  
  
          // 5. 用对称密钥加密通信（AES-GCM示例）
          String plaintext = "Hello, KEM!";
          System.out.println("原始数据：" + plaintext);
  
          // 5.1 发送方加密
          Cipher aesGcm = Cipher.getInstance("AES/GCM/NoPadding");
          byte[] iv = new byte[12]; // GCM推荐12字节IV
          SecureRandom random = new SecureRandom();
          random.nextBytes(iv); // 随机生成IV
          GCMParameterSpec gcmParamSpec = new GCMParameterSpec(128, iv); // 128位认证标签
          aesGcm.init(Cipher.ENCRYPT_MODE, symmetricKey, gcmParamSpec);
          byte[] ciphertext = aesGcm.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
  
          // 5.2 接收方解密（需获取IV和密文）
          Cipher decryptCipher = Cipher.getInstance("AES/GCM/NoPadding");
          decryptCipher.init(Cipher.DECRYPT_MODE, receivedSymmetricKey, gcmParamSpec);
          byte[] decrypted = decryptCipher.doFinal(ciphertext);
          System.out.println("解密数据：" + new String(decrypted, StandardCharsets.UTF_8));
      }
  }
  ```

- **面试常见问题：**

  - **Q:** 什么是 KEM (JEP 452)？
  - **A:** 它是一个面向高级密码学的新 API。它提供了一种标准化的方式来"封装"（即用公钥加密）对称密钥，以便在双方之间安全地传输。普通业务开发者几乎不会用到，它主要是为了增强 Java 平台的安全基础，特别是为未来的后量子加密做准备。

------





## Java22-25新特性



### 1、IO 类

*java.lang.IO 类提供了一系列静态方法，旨在让初学者能够更轻松地进行控制台输入输出操作，而无需记忆复杂的 System.out 语法。*

下面的表格清晰地展示了其核心方法：

| 方法签名                       | 功能说明                 | 传统等价写法                                |
| ------------------------------ | ------------------------ | ------------------------------------------- |
| `void println(Object obj)`     | 打印对象并换行           | `System.out.println(obj)`                   |
| `void print(Object obj)`       | 打印对象不换行           | `System.out.print(obj)`                     |
| `String readln()`              | 从标准输入读取一行       | `new Scanner(System.in).nextLine()`         |
| `String readln(String prompt)` | 先打印提示符，再读取一行 | `System.out.print(prompt); new Scanner(...` |

#### 版本历程

| 版本   | 状态       | 说明                                         |
| ------ | ---------- | -------------------------------------------- |
| JDK 21 | 预览特性   | 首次引入 java.lang.IO 类                     |
| JDK 22 | 第二次预览 | 小幅调整和改进                               |
| JDK 23 | 继续预览   | 持续优化                                     |
| JDK 25 | 标准特性   | 与 “紧凑源文件与实例 main 方法” 一起成为标准 |

#### 重要说明

1. **自动导入**：由于 IO 类位于 `java.lang` 包，它在所有 Java 源文件中都是**自动导入**的，无需显式编写 `import` 语句。
2. **设计目的**：这个类主要是为以下场景设计的：
   - Java 初学者：降低学习曲线。这个特性与 “紧凑 main 方法” 一起，让 Java 对新手更加友好，同时保持了与现有代码的完全兼容性。
   - 单文件程序：快速原型和小工具开发
   - 教育场景：简化教学示例代码
3. **生产环境**：对于大型企业级应用，仍然推荐使用传统的 `System.out` / `System.err` 和更完善的输入处理机制。



```java
import java.util.Scanner;

public class ConsoleIODemo {
    // 传统方式实现控制台交互（JDK 21之前）
    public static void testBefore() {
        // 创建Scanner对象处理输入
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("请输入你的姓名：");
        String name = scanner.nextLine();
        
        System.out.print("请输入一段想分享的话：");
        String message = scanner.nextLine();
        
        System.out.println("你好，" + name + "！你分享的内容是：" + message);
        
        // 关闭Scanner释放资源
        scanner.close();
    }

    // 使用java.lang.IO类实现（JDK 25+ 标准特性）
    public static void testAfter25() {
        // 直接调用IO类的静态方法，无需创建对象和导入
        String name = IO.readln("请输入你的姓名：");
        String message = IO.readln("请输入一段想分享的话：");
        
        IO.println("你好，" + name + "！你分享的内容是：" + message);
    }

    // 紧凑main方法（JDK 21+ 特性，配合IO类更简洁）
    void main() {
        testAfter25(); // 调用IO类实现的方法
        // testBefore(); // 可注释切换测试传统方式
    }
}
```





### 25. 紧凑的源文件和实例 main 方法 (JEP 463, JEP 445)



- **适用版本：** Java 21 (预览), Java 22 (预览), **Java 23 (正式)**。

- **特性名称：** 未命名类 (Unnamed Classes) 和实例 Main 方法 (Instance Main Methods)。

- **解决了什么问题：** Java 对新手的“入门仪式”过于繁琐。编写一个 "Hello World" 需要理解 `public class`、`static`、`String[] args` 等大量概念。

- **之前的解决方案 (Java 11+)：**

  - 你仍然需要编写一个完整的类，只是可以用 `java HelloWorld.java` (JEP 330) 来运行它。
  - `jshell` (Java 9) 提供了交互式编程，但不是运行标准程序。

- **新的解决方案 (Java 23)：**

  1. **实例 Main 方法：** 允许 `main` 方法不再是 `public static`，也不需要 `String[] args`。
  2. **未命名类：** 允许你在 `.java` 文件的顶层直接编写方法和字段，编译器会自动为你包裹在一个“未命名类”中。

- **代码对比：**

  - **之前 (Java 8/11)：** (繁琐的模板)

    ```Java
    // 文件名: HelloWorld.java
    public class HelloWorld {
        // 1. 必须声明一个类
        // 2. 必须是 public static void main(String[] args)
        public static void main(String[] args) {
            System.out.println("Hello, World!");
        }
    }
    // 运行: javac HelloWorld.java && java HelloWorld
    ```
    
  - **之后 (JEP 463, Java 23)：** (为学习和简单脚本优化)

    ```Java
    // 文件名: hello.java
    
    // 验证点 1：不再需要 "class ..."
    // 验证点 2：main 方法可以是实例方法，且无需参数
    void main() {
        System.out.println("Hello, Java 23!");
    }
    
    // 运行 (使用 Java 23+): java hello.java
    
    // ------------------------------------
    // 你还可以有字段和其他方法
    
    String greeting = "Hello, ";
    
    void main() {
        System.out.println(greet("World"));
    }
    
    String greet(String name) {
        return greeting + name;
    }
    ```
  
- **面试常见问题：**

  - **Q:** JEP 463 (实例 Main 方法) 是为了取代 `public static void main` 吗？
  - **A:** 不是。它是为了**简化 Java 的入门学习**和**小型脚本**的编写。对于大型、复杂的应用程序，`public static main` 仍然是标准的入口点。这个新特性旨在让初学者可以*逐步*学习 Java，先从简单的 `void main()` 开始。

------



### 26. 灵活的构造函数体 (JEP 447)

- **适用版本：** Java 22 (预览)

- **特性名称：** 构造函数中 `super()` 之前的语句 (Statements before `super()`)。

- **解决了什么问题：** Java 长期以来严格规定，在子类的构造函数中，**第一行**必须是 `super(...)` 或 `this(...)`。这导致了一个问题：你无法在调用父类构造函数*之前*验证参数或准备参数。

| 特性对比维度 | 传统构造函数                           | 灵活构造函数（灵活构造函数体）            |
| ------------ | -------------------------------------- | ----------------------------------------- |
| 执行顺序     | `super()` 或 `this()` 必须是第一行语句 | 允许在 `super()` 或 `this()` 之前执行代码 |
| 代码组织     | 参数验证等逻辑需放在父类构造调用之后   | 可在调用父类构造前进行参数验证、计算      |
| 安全性       | 非法参数可能已传入父类构造函数         | 实现 “快速失败”，在分配资源前拒绝非法参数 |
| 可读性       | 初始化逻辑可能分散                     | 相关初始化逻辑更集中                      |

> 重要限制

尽管灵活性增加了，但为了确保对象初始化的安全性，JVM 仍然施加了一些关键限制：

- **禁止访问未完全初始化的对象**：在调用 `super()` 或 `this()` 之前，你不能引用正在构建的对象。这意味着：
  - 不能使用 `this` 关键字
  - 不能访问实例字段（除非你已经明确初始化了它们）
  - 不能调用实例方法

简单来说，在 “前置” 代码区段中，你只能使**用静态方法、静态字段，以及构造函数本身的参数**。



- **之前的解决方案 (Java 8/11)：**

  - 1. **参数重复验证：** 在 `super()` 之后再次验证。
  - 1. **静态辅助方法：** 将参数准备逻辑封装在一个 `static` 方法中，然后在 `super()` 调用中内联使用它。

  ```Java
  // 之前 (Java 8)
  public class MyException extends Exception {
  
      public MyException(Object data) {
          // 问题：必须先调用 super()
          // 但如果 data 是 null，我们不想调用 super，而是想抛 NPE
          // 或者，我们需要对 data 进行复杂处理才能传给 super
          super(formatData(data)); // 必须用 static helper
      }
  
      private static String formatData(Object data) {
          if (data == null) {
              throw new NullPointerException("Data cannot be null");
          }
          return data.toString(); // 复杂逻辑
      }
  }
  ```

- **新的解决方案 (Java 22 预览)：** 允许在 `super()` 之前执行不访问 `this`（即不访问实例字段或方法）的语句。

- **代码对比：**

  ```Java
  // 之后 (Java 22 预览)
  public class MyException extends Exception {
  
      public MyException(Object data) {
  
          // 验证点 1：可以在 super() 之前进行校验
          if (data == null) {
              throw new NullPointerException("Data cannot be null");
          }
  
          // 验证点 2：可以准备参数
          String formattedData = data.toString();
  
          // 验证点 3：只要不访问 'this'，这些代码都是合法的
  
          // 现在才调用 super()
          super(formattedData);
      }
  }
  ```

- **面试常见问题：**

  - **Q:** JEP 447 放宽了什么限制？
  - **A:** 它允许在构造函数的 `super()` 调用之前编写代码，例如参数校验或准备。
  - **Q:** 这些代码有什么限制？
  - **A:** 最大的限制是，`super()` 之前的代码**不能**访问 `this` 实例。这意味着你不能调用实例方法、访问实例字段，或创建内部类实例。

------



### 27. 未命名变量和模式 (JEP 456)



- **适用版本：** Java 22 (正式)

- **特性名称：** Unnamed Variables & Patterns。

- **解决了什么问题：** 我们在写代码时，经常被迫声明一些永远不会被使用的变量。

  - 1. `try-catch` 块中的 `Exception e`。
  - 1. `for` 循环中未使用的索引或变量。
  - 1. Lambda 表达式中未使用的参数。
  - 1. `switch` 模式匹配或 `record` 解构中不关心的组件。

- **之前的解决方案：** 声明它，并忍受 IDE 发出的“变量未使用”的警告。

- **新的解决方案 (Java 22)：** 使用**下划线 `_`** 作为未命名变量（或模式）的占位符。

- **代码对比：**

  ```Java
  // 之后 (Java 22)
  
  // 验证点 1：try-catch
  try {
      int i = Integer.parseInt("abc");
  } catch (NumberFormatException _) { // 之前是 (NumberFormatException e)
      System.out.println("无效的数字");
  }
  
  // 验证点 2：for 循环
  // 假设我们只是想循环 10 次，不关心索引
  for (int i = 0, _ = 0; i < 10; i++) { /*...*/ } // (这个用法比较晦涩)
  // 更好的例子：
  Map<String, Integer> map = Map.of("A", 1, "B", 2);
  for (var _ : map.entrySet()) { // 之前是 (var entry : ...)
      // 假设我们只关心循环次数，不关心 entry
  }
  
  // 验证点 3：Lambda
  // BiConsumer<String, String> printBoth = (k, v) -> System.out.println(k + v);
  BiConsumer<String, String> printKeyOnly = (k, _) -> System.out.println(k);
  
  // 验证点 4：模式匹配 (最有用的地方)
  record Point(int x, int y) {}
  Object obj = new Point(10, 20);
  
  // 需求：我只关心 x，不关心 y
  // 之前：if (obj instanceof Point(int x, int y)) { ... } (y 浪费了)
  if (obj instanceof Point(int x, _)) {
      System.out.println("X 坐标: " + x);
  }
  
  // 验证点 5：Switch 模式匹配
  Object obj2 = "Hello";
  switch (obj2) {
      case Integer _ -> System.out.println("是一个整数 (不关心值)");
      case String _ -> System.out.println("是一个字符串 (不关心值)");
      default -> {}
  }
  ```
  
- **面试常见问题：**

  - **Q:** `_` (下划线) 在 Java 22 中有什么用？
  - **A:** 它被用作“未命名变量”或“未命名模式”的占位符。当你被语法要求必须声明一个变量，但你又根本不会使用它时，就可以用 `_` 来代替，这能让代码更简洁，并明确传达“此变量被有意忽略”的意图。

------



### 28. 流收集器 (Stream Gatherers) (JEP 461)



- **适用版本：** Java 22 (预览)

- **解决了什么问题：** `Stream` API 的中间操作（如 `map`, `filter`, `flatMap`）非常强大，但都是“无状态”或“简单有状态”的（如 `distinct`, `sorted`）。如果你想实现一个复杂的、有状态的中间操作（例如：滑动窗口、分组、按条件合并元素），现有的 API 很难做到。

- **之前的解决方案：**
  - 1. 先 `collect` 到 `List`，然后手动遍历处理（破坏了流式处理）。
  - 1. 实现一个极其复杂的 `Spliterator`。
  
- **新的解决方案 (Java 22 预览)：** 引入一个新的中间操作 `gather(Gatherer)`。`Gatherer` 是一个可插拔的中间操作接口，你可以自定义它来处理流元素。

> | 特性     | 传统 collect ()（终止操作）  | 流收集器 Stream.gather ()（中间操作） |
> | -------- | ---------------------------- | ------------------------------------- |
> | 操作位置 | 流的末端                     | 流的中间                              |
> | 结果类型 | 终止流，返回集合或其他结果   | 返回新的 Stream，可继续操作           |
> | 使用场景 | 最终结果收集                 | 数据预处理、分组、窗口化、自定义转换  |
> | 例子     | collect(Collectors.toList()) | gather(Gatherers.windowSliding(3))    |

新增方法

> | 方法名                                   | 功能描述                | 示例输入→输出                   |
> | ---------------------------------------- | ----------------------- | ------------------------------- |
> | windowSliding(int size)                  | 创建滑动窗口            | [1,2,3,4] → [[1,2],[2,3],[3,4]] |
> | windowFixed(int size)                    | 创建固定窗口            | [1,2,3,4,5] → [[1,2,3],[4,5]]   |
> | fold(Supplier, BiFunction)               | 类似 reduce，可改变类型 | [1,2,3] + 初始值 0 → [0,1,3,6]  |
> | scan(Supplier, BiFunction)               | 扫描操作，保留中间结果  | [1,2,3] → [1,3,6]               |
> | mapConcurrent(int parallelism, Function) | 并行映射元素            | [1,2,3] → [2,4,6]（并行处理）   |

- 

- **代码对比：**

  - **需求：** 将一个 `Stream<Integer>` 按照**滑动窗口**（每 3 个元素一组）进行分组。

  - **输入：** `[1, 2, 3, 4, 5, 6]`

  - **输出：** `[ [1, 2, 3], [4, 5, 6] ]` (这是 `windowFixed` 固定窗口)

  - **或输出：** `[ [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6] ]` (这是 `windowSliding` 滑动窗口)

  - **之前 (Java 8/11)：** 极其困难，几乎无法在流中完成。

  - **之后 (Java 22 预览)：**

    ```Java
    import java.util.stream.Gatherers; // Java 22 新增
    import java.util.stream.Stream;
    
    // 验证点 1：固定窗口 (Fixed Window)
    // [1, 2, 3, 4, 5, 6] -> [[1, 2, 3], [4, 5, 6]]
    Stream.of(1, 2, 3, 4, 5, 6)
          .gather(Gatherers.windowFixed(3)) // 使用内置的 Gatherer
          .forEach(System.out::println);
    
    // 输出:
    // [1, 2, 3]
    // [4, 5, 6]
    
    // 验证点 2：滑动窗口 (Sliding Window)
    // [1, 2, 3, 4] -> [[1, 2], [2, 3], [3, 4]]
    Stream.of(1, 2, 3, 4)
          .gather(Gatherers.windowSliding(2))
          .forEach(System.out::println);
    
    // 输出:
    // [1, 2]
    // [2, 3]
    // [3, 4]
    ```

- **面试常见问题：**

  - **Q:** `Stream` 新的 `gather()` 方法是做什么的？
  - **A:** 它是一个新的*中间操作*，允许你插入自定义的、有状态的转换逻辑。它填补了 `map`/`filter`（简单操作）和 `collect`（终端操作）之间的空白。
  - **Q:** `gather()` 和 `collect()` 有什么区别？
  - **A:** `collect()` 是一个**终端操作**，它会消耗流并产出一个最终结果（如 `List` 或 `Map`）。`gather()` 是一个**中间操作**，它会转换流，并产出一个*新的流*，你可以在这个新流上继续执行其他操作（如 `map`, `filter` 等）。

------



### 29. 启动多文件源码程序 (JEP 458)



- **适用版本：** Java 22 (正式)

- **解决了什么问题：** Java 11 引入的“单文件源码程序”(`java MyFile.java`) 非常好用，但它仅限于*单文件*。如果 `MyFile.java` 依赖了同目录下的 `Helper.java`，它就无法工作了。

- **之前的解决方案 (Java 11)：** 回到传统方式，先 `javac MyFile.java Helper.java`，再 `java MyFile`。

- **新的解决方案 (Java 22)：** 增强 `java` 启动器。当你运行 `java MyFile.java` 时，启动器会自动查找并编译 `MyFile.java` 在代码中依赖的、位于同目录或子目录下的其他 `.java` 文件。

- **代码对比：**

  - **文件 1: `Helper.java`**

    ```Java
    package com.example;
    public class Helper {
        public static String getMessage() {
            return "Hello from Helper!";
        }
    }
    ```
    
  - **文件 2: `MyProgram.java`** (与 `Helper.java` 在同一源码树下，例如在 `com/example` 目录)

    ```Java
    package com.example;
    public class MyProgram {
        public static void main(String[] args) {
            // 依赖 Helper 类
            System.out.println(Helper.getMessage());
        }
    }
    ```
    
  - **之前 (Java 11)：**
  
    ```Bash
    # 必须手动编译所有文件
    $ javac com/example/MyProgram.java com/example/Helper.java
    # 运行
    $ java com.example.MyProgram
    > Hello from Helper!
    ```
    
  - **之后 (Java 22)：**
  
    
  
    ```Bash
    # 验证点：直接运行主文件
    # java 启动器会自动找到并(在内存中)编译 Helper.java
    $ java com/example/MyProgram.java
    > Hello from Helper!
    ```
  
- **面试常见问题：**

  - **Q:** JEP 458 和 JEP 330 (单文件) 有什么关系？
  - **A:** JEP 458 是 JEP 330 的自然演进。JEP 330 允许你运行*一个* `.java` 文件。JEP 458 允许你运行*一个* `.java` 文件，并且它会自动处理这个文件所依赖的*其他* `.java` 文件（只要它们在正确的包结构中）。

------



### 30. 作用域值 (Scoped Values) (JEP 464)



- **适用版本：** Java 21 (预览), **Java 23 (第二次预览)** (非常重要)

- **解决了什么问题：** `ThreadLocal` 的问题。

  - `ThreadLocal` 是在 Java 早期用来在线程内部传递数据（如用户身份、事务ID）的。
  - **问题 1 (昂贵)：** `ThreadLocal` 是*可变的*，且生命周期无限。
  - **问题 2 (泄露)：** 如果你忘记 `remove()`，它在线程池中会“泄露”给下一个任务。
  - **问题 3 (与虚拟线程不兼容)：** `ThreadLocal` 的设计思想是“线程很昂贵，数量很少”。而虚拟线程（JEP 444）的核心是“线程很廉价，有几百万个”。在虚拟线程上大量使用 `ThreadLocal` 会导致严重的内存和性能问题。

  | 特性对比       | ThreadLocal                                  | Scoped Values (Java 25)              |
  | -------------- | -------------------------------------------- | ------------------------------------ |
  | 数据可变性     | 值可被任意修改                               | 不可变，一旦绑定无法更改             |
  | 内存管理       | 必须手动调用`remove()`，易导致内存泄漏       | 自动清理，作用域结束即释放           |
  | 虚拟线程支持   | 每个虚拟线程持有数据副本，内存开销大         | 虚拟线程共享数据，内存效率高         |
  | 数据安全       | 任何代码都可修改值，有被篡改风险             | 不可变性确保了数据安全               |
  | 子线程数据继承 | 需使用`InheritableThreadLocal`，且数据为副本 | 子线程（包括结构化并发任务）自动继承 |

- **之前的解决方案：** `ThreadLocal`（现在被视为遗留和危险的 API）。

- **新的解决方案 (Project Loom)：** `ScopedValue` (作用域值)。

  - **不可变 (Immutable)：** `ScopedValue` 一旦绑定，其值在作用域内不可更改。
  - **有界生命周期：** 它的值*只*在特定的代码块（"作用域"）内有效。
  - **为虚拟线程优化：** 高效地在父子线程（包括虚拟线程）间传递数据。

- **代码对比：**

  - **之前 (ThreadLocal - 危险)：**

    ```Java
    // 声明一个静态的 ThreadLocal
    public static final ThreadLocal<String> USER_CONTEXT = new ThreadLocal<>();
    
    public void processRequest(User user) {
        USER_CONTEXT.set(user.name()); // 1. 设置
        try {
            // ... 调用其他方法 ...
            // 中间的方法可以通过 USER_CONTEXT.get() 获取
            serviceLayer(); 
        } finally {
            USER_CONTEXT.remove(); // 2. 必须手动移除，否则会泄露！
        }
    }
    ```
    
  - **之后 (ScopedValue - 安全)：**

    ```Java
    // 声明一个静态的 ScopedValue
    public static final ScopedValue<String> USER_CONTEXT = ScopedValue.newInstance();
    
    public void processRequest(User user) {
        // 验证点 1：使用 ScopedValue.where(...).run(...) 来定义作用域
        // 绑定 USER_CONTEXT 为 user.name()
        // 运行 lambda 表达式
        ScopedValue.where(USER_CONTEXT, user.name())
                   .run(() -> {
                       // 验证点 2：在 lambda 内部，值是可用的
                       // serviceLayer() 可以通过 USER_CONTEXT.get() 获取
                       serviceLayer(); 
                   });
    
        // 验证点 3：
        // lambda 运行结束后，绑定自动失效，无需手动 remove()
        // USER_CONTEXT.get() 在这里会抛出 NoSuchElementException
    }
    
    public void serviceLayer() {
        if (USER_CONTEXT.isBound()) {
            String username = USER_CONTEXT.get(); // 获取值
            System.out.println("Service layer processing for: " + username);
        }
    }
    ```
  
- **面试常见问题：**

  - **Q:** 为什么虚拟线程时代不推荐使用 `ThreadLocal`？
  - **A:** 1. `ThreadLocal` 可变，且需要手动 `remove()`，容易导致数据泄露。 2. 它的设计基于“昂贵的”平台线程，在“廉价的”虚拟线程上使用，其内部实现（`ThreadLocalMap`）会造成高内存开销和性能瓶颈。
  - **Q:** `ScopedValue` 如何解决这些问题？
  - **A:** 1. `ScopedValue` 是*不可变*的。 2. 它的生命周期由 `where(...).run(...)` 语法块*严格限定*，离开作用域自动失效，无需手动清理。 3. 它的实现针对虚拟线程做了优化，数据传递高效。

------

### 8、原始类型模式匹配（预览）

💡**原始类型模式匹配**是 Java 在语言层面统一类型模式匹配的重要一步，它让你能在 `instanceof` 和 `switch` 中直接匹配如 `int`、`long`、`double` 这类基础数据类型。这在处理 `Object` 类型或泛型时尤为有用，可帮你写出更直观、更简洁的代码。

💡Java 的模式匹配功能是逐步完善的：

- JDK12-17 引入了与 `instanceof` 的模式匹配。
- JDK 18-21 引入了与 `switch` 的模式匹配。
- JDK 23 开始允许在模式匹配中使用所有原始类型，包括 `long`、`float`、`double` 和 `boolean`。
- JDK 25 中的原始类型模式匹配是其第三次预览，意味着语法和功能已基本稳定，但仍可能根据反馈进行微调。

示例 1：`instanceof` 原始类型模式匹配

```java
public class PrimitiveInstanceOfDemo {
    public static void processObject(Object obj) {
        // 直接匹配原始类型模式（int、long、double）
        if (obj instanceof int i) {
            System.out.println("匹配到 int 类型，值为：" + i);
        } else if (obj instanceof long l) {
            System.out.println("匹配到 long 类型，值为：" + l);
        } else if (obj instanceof double d) {
            System.out.println("匹配到 double 类型，值为：" + d);
        } else {
            System.out.println("未匹配到原始类型，对象类型为：" + obj.getClass());
        }
    }

    public static void main(String[] args) {
        processObject(100);        // 匹配 int
        processObject(200L);       // 匹配 long
        processObject(3.14);       // 匹配 double
        processObject("Java");     // 未匹配，输出字符串类型
    }
}
```

示例 2：`switch` 原始类型模式匹配

```java
public class PrimitiveSwitchDemo {
    public static void processNumber(Number num) {
        switch (num) {
            // 匹配 Integer 并提取为 int 变量
            case Integer i -> System.out.println("这是 int 类型，值为：" + i);
            // 匹配 Long 并提取为 long 变量
            case Long l -> System.out.println("这是 long 类型，值为：" + l);
            // 匹配 Double 并提取为 double 变量
            case Double d -> System.out.println("这是 double 类型，值为：" + d);
            default -> System.out.println("不支持的数值类型");
        }
    }

    public static void main(String[] args) {
        processNumber(5);      // 匹配 int
        processNumber(10L);    // 匹配 long
        processNumber(2.718);  // 匹配 double
    }
}
```



### 31. 结构化并发 (Structured Concurrency) (JEP 462)



- **适用版本：** Java 21 (预览), **Java 23 (第二次预览)** (非常重要)

- **解决了什么问题：** 传统并发编程（使用 `ExecutorService` 和 `Future`）的*错误处理*和*任务取消*非常困难，容易导致线程泄露。

  - **问题：** 假设你提交了 2 个任务（`taskA`, `taskB`）到线程池。如果 `taskA` 失败了，你希望 `taskB` 自动取消（如果它还在运行），但 `Future` API 很难做到这一点。如果主线程在 `taskA.get()` 时崩溃，`taskB` 所在的线程可能会永远泄露。

  | 特性       | 传统 ExecutorService                    | 结构化并发（StructuredTaskScope）           |
  | ---------- | --------------------------------------- | ------------------------------------------- |
  | 子任务取消 | 需手动调用 Future.cancel ()，易遗漏     | 自动取消（任一失败 / 主线程中断时）         |
  | 线程泄漏   | 易发生（如子任务未取消，主线程退出）    | 无泄漏（try-with-resources 自动关闭 scope） |
  | 错误处理   | 需逐个处理 Future.get () 异常，代码繁琐 | 集中处理 FailedException，逻辑清晰          |
  | 可观测性   | 线程无层级关系，dump 难关联任务         | 任务层级明确，dump 可直接体现父子关系       |
  | 线程模型   | 依赖线程池，重量级（适合计算密集）      | 默认用虚拟线程，轻量级（适合 I/O 密集）     |

- **之前的解决方案：** `ExecutorService.submit()`, `CompletableFuture`。代码分散，难以管理。

- **新的解决方案 (Project Loom)：** `StructuredTaskScope` API。

  - 它将并发任务的生命周期与*代码块*（`try-with-resources`）绑定。
  - **核心原则：** 如果一个任务分裂成多个子任务，那么这些子任务必须在主任务继续之前全部完成。
  - 提供了清晰的失败策略（如：任一失败则全部取消，任一成功则全部取消）。

- **代码对比：**

  - **需求：** 并发调用两个服务（`findUser()` 和 `fetchOrder()`），然后合并结果。

  - **之前 (Future - 难以管理)：**

    ```Java
    ExecutorService exec = Executors.newFixedThreadPool(2);
    Future<String> userFuture = exec.submit(() -> findUser());
    Future<String> orderFuture = exec.submit(() -> fetchOrder());
    
    // 问题：如果 findUser() 抛异常, fetchOrder() 还在运行
    // 问题：如果主线程在这里崩溃，线程池可能泄露
    String user = userFuture.get();
    String order = orderFuture.get();
    ```
    
  - **之后 (Structured Concurrency - 安全)：**

    ```Java
    // 验证点 1：使用 try-with-resources 定义任务作用域
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    
        // 验证点 2：fork 任务 (提交到虚拟线程)
        Subtask<String> userTask = scope.fork(() -> findUser());
        Subtask<String> orderTask = scope.fork(() -> fetchOrder());
    
        // 验证点 3：等待所有任务完成
        scope.join();
    
        // 验证点 4：
        // 如果 findUser() 或 fetchOrder() 任意一个失败,
        // ShutdownOnFailure 策略会自动取消另一个任务,
        // 并且 join() 会抛出异常。
        scope.throwIfFailed(); // 如果有失败，在这里抛出
    
        // 验证点 5：只有全部成功，才能获取结果
        String user = userTask.get();
        String order = orderTask.get();
        System.out.println(user + " & " + order);
    
    } // 离开 try 块，scope 自动关闭，保证所有任务终结
    ```
  
- **面试常见问题：**

  - **Q:** 什么是结构化并发？
  - **A:** 它是一种新的并发编程模型，使用 `StructuredTaskScope` 将并发子任务的生命周期与一个*代码块*绑定。这极大地简化了错误处理和任务取消，确保不会有“泄露”的线程。
  - **Q:** `StructuredTaskScope.ShutdownOnFailure` 是什么意思？
  - **A:** 它是一种策略。意味着在 `scope` 中，只要有*任何一个*子任务失败（抛出异常），`scope` 会立即*取消*所有其他仍在运行的子任务，然后 `join()` 返回。

------

### 10、Stable Values（预览）

💡Java 25 引入的 **Stable Values** 是一个旨在**简化延迟初始化、同时保证线程安全和性能**的新特性，目前仍处于预览阶段。简单来说，你可以用它来创建那些只需要初始化一次、之后便不可变的对象，它融合了 `final` 字段的性能优势与懒加载的灵活性。

新旧方式对比

为了让你快速了解它的价值，下面这个表格对比了传统的懒加载方式与使用 `StableValue` 的区别：

| 特性       | 传统懒加载方式                             | StableValue 方式                                    |
| ---------- | ------------------------------------------ | --------------------------------------------------- |
| 线程安全   | 需手动处理（如加锁）                       | 内置线程安全，初始化逻辑仅执行一次                  |
| 代码简洁性 | 需要重复的 `if (xxx == null)` 判断模板代码 | 一行代码完成线程安全的延迟初始化                    |
| 性能优化   | JVM 难以优化，可能影响内联和常量折叠       | JVM 可像优化 `final` 字段一样进行激进优化（如内联） |
| 内存可见性 | 需依赖 `volatile` 等关键字保证             | 由 API 内部保证                                     |

如何使用 Stable Values？（测试代码示例）

下面通过代码示例展示 `StableValue` 的使用方式：

```java
import java.lang.StableValue;

// 定义一个配置类，用于延迟初始化
public record Config(String dbUrl, String dbUsername, String dbPassword, String logLevel) {}

public class StableValueDemo {
    // 使用StableValue实现线程安全的延迟初始化
    private static final StableValue<Config> CONFIG = StableValue.lazy(
        () -> new Config(
            "jdbc:mysql://localhost:3306/test",
            "admin",
            "password",
            "INFO"
        )
    );

    public static void main(String[] args) {
        // 多次获取，验证只初始化一次
        Config config1 = CONFIG.get();
        Config config2 = CONFIG.get();
        
        System.out.println("配置是否相同：" + (config1 == config2)); // 输出true，说明只初始化了一次
        System.out.println("数据库URL：" + config1.dbUrl());
        System.out.println("日志级别：" + config1.logLevel());
    }
}
```

代码说明

- `StableValue.lazy(Supplier)` 方法用于创建一个延迟初始化的稳定值，Supplier 中的初始化逻辑**只会执行一次**。
- 多次调用 `get()` 方法会返回同一个实例，既保证了对象的不可变性，又通过内置机制确保了线程安全。
- 该特性在 JVM 层面可被激进优化，性能媲美 `final` 字段，同时具备懒加载的灵活性，适合用于配置类、单例对象等 “仅需初始化一次” 的场景。





### 32. 字符串模板 (String Templates) (JEP 465)



- **适用版本：** Java 21/22 (预览), **Java 23 (第三次预览)**
- **特性名称：** String Templates

+ **关键版本历程**

| JDK 版本 | 类型     | 状态与关键事件           |
| -------- | -------- | ------------------------ |
| JDK 21   | 预览特性 | 首次引入，作为预览功能   |
| JDK 22   | 预览特性 | 继续预览，未成为正式特性 |
| JDK 23   | 已移除   | 该特性被完全移除         |

> 被移除的原因与未来
>
> 字符串模板在 JDK 23 中被移除，核心原因在于其设计上存在争议，特别是`StringTemplate.Processor`接口被认为过于复杂和繁琐。开发团队认为，在许多场景下，直接在相关类中添加一个接受`StringTemplate`参数的方法是更简洁清晰的设计。由于对如何修改缺乏足够的社区共识，为了避免有缺陷的设计被大量采用导致日后难以修正，决定先将其移除。
>
> 需要注意的是，移除并不意味着该功能被永久放弃。未来我们可能会看到一个经过重新设计、更简洁的字符串模板方案。

- **解决了什么问题：**

  1. **字符串拼接 ( + )：** 繁琐且性能低下。
  2. **`String.format()`：** 格式和参数是分开的，类型不安全。
  3. **`MessageFormat`：** API 笨重。
  4. **安全隐患：** 拼接字符串（尤其是 SQL 或 JSON）极易导致*注入攻击*。

- **之前的解决方案：** 字符串拼接 `+`，`StringBuilder`，`String.format()`。

- **新的解决方案 (Java 23 预览)：** 引入*模板处理器* (Template Processor) 和 `\{}` 语法。

- **代码对比：**

  - **之前 (Java 8)：** (繁琐且不安全)

    ```Java
    String name = "Alice";
    int age = 30;
    
    // 方案 1: + 拼接
    String s1 = "User " + name + " is " + age + " years old.";
    
    // 方案 2: String.format
    String s2 = String.format("User %s is %d years old.", name, age);
    
    // 方案 3 (危险的 SQL):
    String query = "SELECT * FROM users WHERE name = '" + name + "'"; // SQL 注入!
    ```
    
  - **之后 (JEP 465, Java 23 预览)：**

    ```Java
    String name = "Alice";
    int age = 30;
    
    // 验证点 1：使用 STR 模板处理器
    // \{name} 会被自动替换
    String s1 = STR."User \{name} is \{age} years old.";
    System.out.println(s1); // "User Alice is 30 years old."
    
    // 验证点 2：STR 会自动处理和清理插入的值 (安全)
    String s2 = STR."User \{name} is \{age * 2} years old."; // 允许表达式
    System.out.println(s2); // "User Alice is 60 years old."
    
    // 验证点 3：安全性 (核心)
    // 假设 name 变量来自用户输入，是恶意的
    String maliciousName = "Alice'; DROP TABLE users; --";
    
    // 之前 (Java 8) - 灾难!
    String query_unsafe = "SELECT * FROM users WHERE name = '" + maliciousName + "'";
    // "SELECT * FROM users WHERE name = 'Alice'; DROP TABLE users; --'"
    
    // 之后 (JAF 465) - 安全的
    // (注：实际的 JDBC 不会用 STR，而是用 JEP 465 定义的自定义处理器，
    // 比如 PreparedStatement.process(PS) )
    // 但 STR 本身是安全的：
    String json = STR."{\"name\": \"\{maliciousName}\"}";
    // 输出 (验证点 4：自动转义):
    // {"name": "Alice'; DROP TABLE users; --"}
    // 它不会破坏 JSON 结构！
    ```

- **面试常见问题：**

  - **Q:** 什么是字符串模板 (JEP 465)？
  - **A:** 它是一种新的字符串字面量，允许你通过 `\{variable}` 的方式将变量和表达式安全、便捷地嵌入到字符串中。
  - **Q:** `STR."..."` 中的 `STR` 是什么？
  - **A:** `STR` 是一个内置的*模板处理器* (Template Processor)。它的工作是接收 `\{}` 占位符和旁边的字符串片段，将它们安全地插值（拼接）成一个最终的 `String`。
  - **Q:** 它比 `+` 拼接好在哪里？
  - **A:** 1. **可读性**：`\{name}` 比 `"` + `name` + `"` 更清晰。 2. **安全性**：`STR` 处理器会自动对插入的值进行必要的转义，防止注入攻击。未来还会有专门用于 SQL 或 JSON 的处理器。



