> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.runoob.com](https://www.runoob.com/regexp/regexp-intro.html) [正则表达式 – 教程](https://www.runoob.com/regexp/regexp-tutorial.html "正则表达式 – 教程")[正则表达式 – 语法](https://www.runoob.com/regexp/regexp-syntax.html "正则表达式 – 语法")

## 正则表达式可以做什么？

- **查找：**在文本中找到特定模式的内容
- **替换：**将符合某种模式的文本替换为其他内容
- **验证：**检查输入的数据是否符合预期格式
- **提取：**从复杂文本中提取需要的信息

## 实例

从字符串 str 中提取数字部分的内容(匹配一次)：

```javascript
var str = "abc123def";
var patt1 = /[0-9]+/;
document.write(str.match(patt1));
```

以下标记的文本是获得的匹配的表达式：

**123**

## 正则表达式的模式

正则表达式的模式可以包括以下内容：

- 字面值字符：例如字母、数字、空格等，可以直接匹配它们自身。
- 特殊字符：例如点号 `.`、星号 `*`、加号 `+`、问号 `?` 等，它们具有特殊的含义和功能。
- 字符类：用方括号 `[ ]` 包围的字符集合，用于匹配方括号内的任意一个字符。
- 元字符：例如 `\d`、`\w`、`\s` 等，用于匹配特定类型的字符，如数字、字母、空白字符等。
- 量词：例如 `{n}`、`{n,}`、`{n,m}` 等，用于指定匹配的次数或范围。
- 边界符号：例如 `^`、`$`、`\b`、`\B` 等，用于匹配字符串的开头、结尾或单词边界位置。

## 简介

除非您以前使用过正则表达式，否则您可能不熟悉一些术语。但是，毫无疑问，您已经使用过不涉及脚本的某些正则表达式概念。

例如，您很可能使用 `?` 和 `*` 通配符来查找硬盘上的文件。`?` 通配符匹配文件名中的 0 个或 1 个字符，而 `*` 通配符匹配零个或多个字符。像 `data(\w)?\.dat` 这样的模式将查找下列文件：

```
data.dat
data1.dat
data2.dat
datax.dat
dataN.dat
```

使用 `*` 字符代替 `?` 字符扩大了找到的文件的数量。`data.*\.dat` 匹配下列所有文件：

```
data.dat
data1.dat
data2.dat
data12.dat
datax.dat
dataXYZ.dat
```

尽管这种搜索方法很有用，但它还是有限的。通过理解 `*` 通配符的工作原理，引入了正则表达式所依赖的概念，但正则表达式功能更强大，而且更加灵活。

正则表达式的使用，可以通过简单的办法来实现强大的功能。下面先给出一个简单的示例：

![](./images/1、正则表达式 – 简介/CEBB49BB-B1AD-4539-AC7A-B40DDC62D1B2-1751471143094-3.jpg)

*   `^` 为匹配输入字符串的开始位置。
    
*   `[0-9]+`匹配多个数字， `[0-9]` 匹配单个数字，`+` 匹配一个或者多个。
    
*   `abc$`匹配字母 `abc` 并以 `abc` 结尾，`$` 为匹配输入字符串的结束位置。
    

我们在写用户注册表单时，只允许用户名包含**字符、数字、下划线和连接字符** `-`，并设置用户名的长度，我们就可以使用以下正则表达式来设定。

```
^[a-zA-Z0-9_-]{3,15}$
```

![](./images/1、正则表达式 – 简介/regexp-cn.png)

*   `^` 表示匹配字符串的开头。
*   `[a-zA-Z0-9_-]` 表示字符集，包含小写字母、大写字母、数字、下划线和连接字符 `-`。
*   `{3,15}` 表示前面的字符集最少出现 3 次，最多出现 15 次，从而限制了用户名的长度在 3 到 15 个字符之间。
*   `$` 表示匹配字符串的结尾。

以上的正则表达式可以匹配 **runoob、runoob1、run-oob、run_oob**， 但不匹配 **ru**，因为它包含的字母太短了，小于 3 个无法匹配。也不匹配 **runoob$**, 因为它包含特殊字符。

```javascript
var str = "123abc";
var patt1 = /^[0-9]+abc$/;
document.write(str.match(patt1));

 123abc
```

正则表达式元字符和特性
-----------

### 字符匹配

*   普通字符：普通字符按照字面意义进行匹配，例如匹配字母 "a" 将匹配到文本中的 "a" 字符。
*   元字符：元字符具有特殊的含义，例如 `\d` 匹配任意数字字符，`\w` 匹配任意字母数字字符，`.` 匹配任意字符（除了换行符）等。

### 量词

*   `*`：匹配前面的模式零次或多次。
*   `+`：匹配前面的模式一次或多次。
*   `?`：匹配前面的模式零次或一次。
*   `{n}`：匹配前面的模式恰好 n 次。
*   `{n,}`：匹配前面的模式至少 n 次。
*   `{n,m}`：匹配前面的模式至少 n 次且不超过 m 次。

### 字符类

*   `[ ]`：匹配括号内的任意一个字符。例如，`[abc]` 匹配字符 "a"、"b" 或 "c"。
*   `[^ ]`：匹配除了括号内的字符以外的任意一个字符。例如，`[^abc]` 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符。

### 边界匹配

*   `^`：匹配字符串的开头。
*   `$`：匹配字符串的结尾。
*   `\b`：匹配单词边界。
*   `\B`：匹配非单词边界。

### 分组和捕获

*   `( )`：用于分组和捕获子表达式。
*   `(?: )`：用于分组但不捕获子表达式。

### 特殊字符

*   `\`：转义字符，用于匹配特殊字符本身。
*   `.`：匹配任意字符（除了换行符）。
*   `|`：用于指定多个模式的选择。

为什么使用正则表达式？
-----------

典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。

通过使用正则表达式，可以：

*   测试字符串内的模式。  
    例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
*   替换文本。  
    可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
*   基于模式匹配从字符串中提取子字符串。  
    可以查找文档内或输入域内特定的文本。

例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

发展历史
----

正则表达式的 "祖先" 可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。

1951 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为 "神经网事件的表示法" 的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为 "正则集的代数" 的表达式，因此采用 "正则表达式" 这个术语。

随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 grep 编辑器。

大致发展历史如下：

*   1951 年：计算理论的奠基人之一，美国计算机科学家 Stephen Kleene 首次提出了正则语言的概念，并使用形式化的方法来描述这种语言。这为正则表达式的发展奠定了理论基础。
    
*   1960 年代：Ken Thompson，Unix 操作系统的共同创始人之一，开发了第一个实际应用正则表达式的程序，它是 Unix 中 grep 命令的一部分。这标志着正则表达式的实际应用。
    
*   1970 年代：Ken Thompson 和 Rob Pike 开发了第一个正则表达式引擎，在 Unix 系统中广泛使用，这对正则表达式的普及起到了关键作用。
    
*   1986 年：Philip Hazel 开发了 PCRE（Perl Compatible Regular Expressions）库，它是一种正则表达式库，允许在不同编程语言中使用 Perl 风格的正则表达式。
    
*   1997 年：IEEE 发布了 POSIX.2 标准，其中包括了正则表达式的标准规范，这使得正则表达式在不同 Unix 系统中的行为更加一致。
    
*   2000 年代以后：正则表达式在计算机编程和文本处理中变得越来越流行，支持正则表达式的编程语言和工具变得更加丰富和强大，如 Perl、Python、Java、JavaScript 等。
    
*   当前：正则表达式仍然是文本处理和数据提取的重要工具，它在数据科学、文本分析、网络爬虫、字符串搜索和替换等领域都有广泛的应用。
    

应用领域
----

目前，正则表达式已经在很多软件中得到广泛的应用，包括 *nix（Linux, Unix 等）、HP 等操作系统，PHP、C#、Java 等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。

### C# 正则表达式

在我们的 C# 教程中，[C# 正则表达式](/csharp/csharp-regular-expressions.html) 这一章节专门介绍了有关 C# 正则表达式的知识。

### Java 正则表达式

在我们的 Java 教程中，[Java 正则表达式](/java/java-regular-expressions.html) 这一章节专门介绍了有关 Java 正则表达式的知识。

### JavaScript 正则表达式

在我们的 JavaScript 教程中，[JavaScript RegExp 对象](/js/js-obj-regexp.html) 这一章节专门介绍了有关 JavaScript 正则表达式的知识，同时我们还提供了完整的 [JavaScript RegExp 对象参考手册](/js/js-obj-regexp.html)。

### Python 正则表达式

在我们的 Python 基础教程中，[Python 正则表达式](/python/python-reg-expressions.html) 这一章节专门介绍了有关 Python 正则表达式的知识。

### Ruby 正则表达式

在我们的 Ruby 教程中，[Ruby 正则表达式](/ruby/ruby-regular-expressions.html) 这一章节专门介绍了有关 Ruby 正则表达式的知识。

<table><tbody><tr><td><b>命令或环境</b></td><td><b>.</b></td><td><b>[ ]</b></td><td><b>^</b></td><td><b>$</b></td><td><b>\(\)</b></td><td><b>\{\}</b></td><td><b>?</b></td><td><b>+</b></td><td><b>|</b></td><td><b>( )</b></td></tr><tr><td><b>vi</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>　</td><td>　</td><td>　</td><td>　</td></tr><tr><td><b>Visual C++</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>　</td><td>　</td><td>　</td><td>　</td></tr><tr><td><b>awk</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>awk 是支持该语法的，只是要在命令 行加入 --posix or --re-interval 参数即可，可见 man awk 中的 interval expression</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><b>sed</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>　</td><td>　</td><td>　</td></tr><tr><td><b>delphi</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><b>python</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><b>java</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√　</td><td>√　</td></tr><tr><td><b>javascript</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><b>php</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>　</td><td>　</td><td>　</td><td>　</td></tr><tr><td><b>perl</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td><b>C#</b></td><td>√</td><td>√</td><td>√</td><td>√</td><td>　</td><td>　</td><td width="12">√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table>